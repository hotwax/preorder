"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeGenerateCode = exports.compile = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const debug_1 = require("debug");
const index_1 = require("./generator/index");
const utils_1 = require("./utils");
const SUPPORTED_FORMAT = ['.json', '.json5', '.yaml', '.yml'];
const debug = debug_1.debug('@intlify/cli:api');
/**
 * Compile i18n resources
 *
 * @param source - the i18n resource source path, you can use glob pattern
 * @param output - the compiled i18n resource output path
 * @param options - {@link CompileOptions}
 *
 * @remarks
 * This functoin is **asyncronous** function. If you want to get about error details, use the handler of {@link CompileOptions} and {@link CompileErrorCodes}
 *
 * @returns `true` when all i18n resource successfuly compile, not `false`
 *
 * @public
 */
async function compile(source, output, options = {}) {
    let ret = true;
    const targets = await utils_1.globAsync(source);
    debug('compile: targets', targets);
    for (const target of targets) {
        const parsed = path_1.default.parse(target);
        debug('parsed', parsed);
        if (!parsed.ext) {
            continue;
        }
        const filename = `${parsed.name}.js`;
        const generatePath = path_1.default.resolve(output, filename);
        if (!SUPPORTED_FORMAT.includes(parsed.ext)) {
            options.onError &&
                options.onError(1 /* NOT_SUPPORTED_FORMAT */, target, generatePath);
            ret = false;
            continue;
        }
        const source = await fs_1.promises.readFile(target, { encoding: 'utf-8' });
        const generate = /\.json?5/.test(parsed.ext) ? index_1.generateJSON : index_1.generateYAML;
        let occuredError = false;
        const { code } = generate(source, {
            type: 'plain',
            filename: target,
            env: 'production',
            onError: (msg) => {
                occuredError = true;
                options.onError &&
                    options.onError(3 /* INTERNAL_COMPILE_ERROR */, target, generatePath, msg);
                ret = false;
            },
            onWarn: (msg) => {
                options.onError &&
                    options.onError(2 /* INTERNAL_COMPILE_WARNING */, target, generatePath, msg);
                ret = false;
            }
        });
        if (!occuredError) {
            await writeGenerateCode(output, filename, code);
            options.onCompile && options.onCompile(target, generatePath);
        }
    }
    return ret;
}
exports.compile = compile;
async function writeGenerateCode(target, filename, code) {
    await fs_1.promises.mkdir(target, { recursive: true });
    const generatePath = path_1.default.resolve(target, filename);
    await fs_1.promises.writeFile(generatePath, code);
    return generatePath;
}
exports.writeGenerateCode = writeGenerateCode;
