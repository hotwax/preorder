import { parseQuery, createRouter as createRouter$1, createWebHistory as createWebHistory$1, createWebHashHistory as createWebHashHistory$1, createMemoryHistory as createMemoryHistory$1 } from 'vue-router';
import { shallowRef } from 'vue';

const createLocationHistory = () => {
    const locationHistory = [];
    const tabsHistory = {};
    const add = (routeInfo) => {
        switch (routeInfo.routerAction) {
            case "replace":
                replaceRoute(routeInfo);
                break;
            case "pop":
                pop(routeInfo);
                break;
            default:
                addRoute(routeInfo);
                break;
        }
        if (routeInfo.routerDirection === 'root') {
            clearHistory();
            addRoute(routeInfo);
        }
    };
    const update = (routeInfo) => {
        const locationIndex = locationHistory.findIndex(x => x.id === routeInfo.id);
        if (locationIndex > -1) {
            locationHistory.splice(locationIndex, 1, routeInfo);
        }
        const tabArray = tabsHistory[routeInfo.tab || ''];
        if (tabArray) {
            const tabIndex = tabArray.findIndex(x => x.id === routeInfo.id);
            if (tabIndex > -1) {
                tabArray.splice(tabIndex, 1, routeInfo);
            }
            else {
                tabArray.push(routeInfo);
            }
        }
        else if (routeInfo.tab) {
            tabsHistory[routeInfo.tab] = [routeInfo];
        }
    };
    const replaceRoute = (routeInfo) => {
        const routeInfos = getTabsHistory(routeInfo.tab);
        routeInfos && routeInfos.pop();
        locationHistory.pop();
        addRoute(routeInfo);
    };
    const pop = (routeInfo) => {
        const tabHistory = getTabsHistory(routeInfo.tab);
        let ri;
        if (tabHistory) {
            // Pop all routes until we are back
            ri = tabHistory[tabHistory.length - 1];
            while (ri && ri.id !== routeInfo.id) {
                tabHistory.pop();
                ri = tabHistory[tabHistory.length - 1];
            }
            // Replace with updated route
            tabHistory.pop();
            tabHistory.push(routeInfo);
        }
        ri = locationHistory[locationHistory.length - 1];
        while (ri && ri.id !== routeInfo.id) {
            locationHistory.pop();
            ri = locationHistory[locationHistory.length - 1];
        }
        // Replace with updated route
        locationHistory.pop();
        locationHistory.push(routeInfo);
    };
    const addRoute = (routeInfo) => {
        const tabHistory = getTabsHistory(routeInfo.tab);
        if (tabHistory) {
            // If the latest routeInfo is the same (going back and forth between tabs), replace it
            if (tabHistory[tabHistory.length - 1] && tabHistory[tabHistory.length - 1].id === routeInfo.id) {
                tabHistory.pop();
            }
            tabHistory.push(routeInfo);
        }
        locationHistory.push(routeInfo);
    };
    const clearHistory = () => {
        locationHistory.length = 0;
        Object.keys(tabsHistory).forEach(key => {
            tabsHistory[key] = [];
        });
    };
    const getTabsHistory = (tab) => {
        let history;
        if (tab) {
            history = tabsHistory[tab];
            if (!history) {
                history = tabsHistory[tab] = [];
            }
        }
        return history;
    };
    const previous = () => locationHistory[locationHistory.length - 2] || current();
    const current = () => locationHistory[locationHistory.length - 1];
    const canGoBack = (deep = 1) => locationHistory.length > deep;
    const getFirstRouteInfoForTab = (tab) => {
        const tabHistory = getTabsHistory(tab);
        if (tabHistory) {
            return tabHistory[0];
        }
        return undefined;
    };
    const getCurrentRouteInfoForTab = (tab) => {
        const tabHistory = getTabsHistory(tab);
        if (tabHistory) {
            return tabHistory[tabHistory.length - 1];
        }
        return undefined;
    };
    const findLastLocation = (routeInfo) => {
        const routeInfos = getTabsHistory(routeInfo.tab);
        if (routeInfos) {
            for (let i = routeInfos.length - 2; i >= 0; i--) {
                const ri = routeInfos[i];
                if (ri) {
                    if (ri.pathname === routeInfo.pushedByRoute) {
                        return ri;
                    }
                }
            }
        }
        for (let i = locationHistory.length - 2; i >= 0; i--) {
            const ri = locationHistory[i];
            if (ri) {
                if (ri.pathname === routeInfo.pushedByRoute) {
                    return ri;
                }
            }
        }
        return undefined;
    };
    return {
        current,
        previous,
        add,
        canGoBack,
        update,
        getFirstRouteInfoForTab,
        getCurrentRouteInfoForTab,
        findLastLocation
    };
};

const ids = { main: 0 };
const generateId = (type = 'main') => {
    var _a;
    const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;
    ids[type] = id;
    return (id).toString();
};

const createIonRouter = (opts, router) => {
    let currentNavigationInfo = { direction: undefined, action: undefined };
    /**
     * Ionic Vue should only react to navigation
     * changes once they have been confirmed and should
     * never affect the outcome of navigation (with the
     * exception of going back or selecting a tab).
     * As a result, we should do our work in afterEach
     * which is fired once navigation is confirmed
     * and any user guards have run.
     */
    router.afterEach((to, _, failure) => {
        if (failure)
            return;
        const { direction, action } = currentNavigationInfo;
        /**
         * When calling router.replace, we are not informed
         * about the replace action in opts.history.listen
         * but we can check to see if the latest routing action
         * was a replace action by looking at the history state.
         */
        const replaceAction = history.state.replaced ? 'replace' : undefined;
        handleHistoryChange(to, action || replaceAction, direction);
        currentNavigationInfo = { direction: undefined, action: undefined };
    });
    const locationHistory = createLocationHistory();
    let currentRouteInfo;
    let incomingRouteParams;
    let currentTab;
    // TODO types
    let historyChangeListeners = [];
    if (typeof document !== 'undefined') {
        document.addEventListener('ionBackButton', (ev) => {
            ev.detail.register(0, (processNextHandler) => {
                opts.history.go(-1);
                processNextHandler();
            });
        });
    }
    opts.history.listen((_, _x, info) => {
        /**
         * history.listen only fires on certain
         * event such as when the user clicks the
         * browser back button. It also gives us
         * additional information as to the type
         * of navigation (forward, backward, etc).
         *
         * We can use this to better handle the
         * `handleHistoryChange` call in
         * router.beforeEach
         */
        currentNavigationInfo = {
            action: info.type,
            direction: info.direction === '' ? 'forward' : info.direction
        };
    });
    const handleNavigateBack = (defaultHref, routerAnimation) => {
        // todo grab default back button href from config
        const routeInfo = locationHistory.current();
        if (routeInfo && routeInfo.pushedByRoute) {
            const prevInfo = locationHistory.findLastLocation(routeInfo);
            if (prevInfo) {
                incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routerAction: 'pop', routerDirection: 'back', routerAnimation: routerAnimation || routeInfo.routerAnimation });
                if (routeInfo.lastPathname === routeInfo.pushedByRoute) {
                    router.back();
                }
                else {
                    router.replace({ path: prevInfo.pathname, query: parseQuery(prevInfo.search) });
                }
            }
            else {
                handleNavigate(defaultHref, 'pop', 'back');
            }
        }
        else {
            handleNavigate(defaultHref, 'pop', 'back');
        }
    };
    const handleNavigate = (path, routerAction, routerDirection, routerAnimation, tab) => {
        incomingRouteParams = {
            routerAction,
            routerDirection,
            routerAnimation,
            tab
        };
        if (routerAction === 'push') {
            router.push(path);
        }
        else {
            router.replace(path);
        }
    };
    // TODO RouteLocationNormalized
    const handleHistoryChange = (location, action, direction) => {
        let leavingLocationInfo;
        if (incomingRouteParams) {
            if (incomingRouteParams.routerAction === 'replace') {
                leavingLocationInfo = locationHistory.previous();
            }
            else {
                leavingLocationInfo = locationHistory.current();
            }
        }
        else {
            leavingLocationInfo = locationHistory.current();
        }
        if (!leavingLocationInfo) {
            leavingLocationInfo = {
                pathname: '',
                search: ''
            };
        }
        const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;
        if (leavingUrl !== location.fullPath) {
            if (!incomingRouteParams) {
                if (action === 'replace') {
                    incomingRouteParams = {
                        routerAction: 'replace',
                        routerDirection: 'none',
                        tab: currentTab
                    };
                }
                else if (action === 'pop') {
                    const routeInfo = locationHistory.current();
                    if (routeInfo && routeInfo.pushedByRoute) {
                        const prevRouteInfo = locationHistory.findLastLocation(routeInfo);
                        incomingRouteParams = Object.assign(Object.assign({}, prevRouteInfo), { routerAction: 'pop', routerDirection: 'back' });
                    }
                    else {
                        incomingRouteParams = {
                            routerAction: 'pop',
                            routerDirection: 'none',
                            tab: currentTab
                        };
                    }
                }
                if (!incomingRouteParams) {
                    incomingRouteParams = {
                        routerAction: 'push',
                        routerDirection: direction || 'forward',
                        tab: currentTab
                    };
                }
            }
            let routeInfo;
            if (incomingRouteParams === null || incomingRouteParams === void 0 ? void 0 : incomingRouteParams.id) {
                routeInfo = Object.assign(Object.assign({}, incomingRouteParams), { lastPathname: leavingLocationInfo.pathname });
                locationHistory.add(routeInfo);
            }
            else {
                const isPushed = incomingRouteParams.routerAction === 'push' && incomingRouteParams.routerDirection === 'forward';
                routeInfo = Object.assign(Object.assign({ id: generateId('routeInfo') }, incomingRouteParams), { lastPathname: leavingLocationInfo.pathname, pathname: location.path, search: location.fullPath && location.fullPath.split('?')[1] || '', params: location.params && location.params, prevRouteLastPathname: leavingLocationInfo.lastPathname });
                if (isPushed) {
                    routeInfo.tab = leavingLocationInfo.tab;
                    routeInfo.pushedByRoute = (leavingLocationInfo.pathname !== '') ? leavingLocationInfo.pathname : undefined;
                }
                else if (routeInfo.routerAction === 'pop') {
                    const route = locationHistory.findLastLocation(routeInfo);
                    routeInfo.pushedByRoute = route === null || route === void 0 ? void 0 : route.pushedByRoute;
                }
                else if (routeInfo.routerAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {
                    const lastRoute = locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);
                    routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;
                }
                else if (routeInfo.routerAction === 'replace') {
                    const currentRouteInfo = locationHistory.current();
                    /**
                     * If going from /home to /child, then replacing from
                     * /child to /home, we don't want the route info to
                     * say that /home was pushed by /home which is not correct.
                     */
                    const currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;
                    const pushedByRoute = (currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname) ? currentPushedBy : routeInfo.pushedByRoute;
                    routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;
                    routeInfo.pushedByRoute = pushedByRoute;
                    routeInfo.routerDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routerDirection) || routeInfo.routerDirection;
                    routeInfo.routerAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routerAnimation) || routeInfo.routerAnimation;
                    routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;
                }
                locationHistory.add(routeInfo);
            }
            currentRouteInfo = routeInfo;
        }
        incomingRouteParams = undefined;
        historyChangeListeners.forEach(cb => cb(currentRouteInfo));
    };
    const getCurrentRouteInfo = () => currentRouteInfo;
    const canGoBack = (deep = 1) => locationHistory.canGoBack(deep);
    const navigate = (navigationOptions) => {
        const { routerAnimation, routerDirection, routerLink } = navigationOptions;
        incomingRouteParams = {
            routerAnimation,
            routerDirection: routerDirection || 'forward',
            routerAction: 'push'
        };
        router.push(routerLink);
    };
    const resetTab = (tab, originalHref) => {
        const routeInfo = locationHistory.getFirstRouteInfoForTab(tab);
        if (routeInfo) {
            const newRouteInfo = Object.assign({}, routeInfo);
            newRouteInfo.pathname = originalHref;
            incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), { routerAction: 'pop', routerDirection: 'back' });
            router.push({ path: newRouteInfo.pathname, query: parseQuery(newRouteInfo.search) });
        }
    };
    const changeTab = (tab, path) => {
        const routeInfo = locationHistory.getCurrentRouteInfoForTab(tab);
        const [pathname] = path.split('?');
        if (routeInfo) {
            incomingRouteParams = Object.assign(Object.assign({}, incomingRouteParams), { routerAction: 'push', routerDirection: 'none', tab });
            /**
             * When going back to a tab
             * you just left, it's possible
             * for the route info to be incorrect
             * as the tab you want is not the
             * tab you are on.
             */
            if (routeInfo.pathname === pathname) {
                router.push({ path: routeInfo.pathname, query: parseQuery(routeInfo.search) });
            }
            else {
                router.push({ path: pathname, query: parseQuery(routeInfo.search) });
            }
        }
        else {
            handleNavigate(pathname, 'push', 'none', undefined, tab);
        }
    };
    const handleSetCurrentTab = (tab) => {
        currentTab = tab;
        const ri = Object.assign({}, locationHistory.current());
        if (ri.tab !== tab) {
            ri.tab = tab;
            locationHistory.update(ri);
        }
    };
    // TODO types
    const registerHistoryChangeListener = (cb) => {
        historyChangeListeners.push(cb);
    };
    return {
        handleNavigateBack,
        handleSetCurrentTab,
        getCurrentRouteInfo,
        canGoBack,
        navigate,
        resetTab,
        changeTab,
        registerHistoryChangeListener
    };
};

const createViewStacks = (router) => {
    let viewStacks = {};
    const clear = (outletId) => {
        delete viewStacks[outletId];
    };
    const getViewStack = (outletId) => {
        return viewStacks[outletId];
    };
    const registerIonPage = (viewItem, ionPage) => {
        viewItem.ionPageElement = ionPage;
        viewItem.ionRoute = true;
    };
    const findViewItemByRouteInfo = (routeInfo, outletId, useDeprecatedRouteSetup = false) => {
        return findViewItemByPath(routeInfo.pathname, outletId, false, useDeprecatedRouteSetup);
    };
    const findLeavingViewItemByRouteInfo = (routeInfo, outletId, mustBeIonRoute = true, useDeprecatedRouteSetup = false) => {
        return findViewItemByPath(routeInfo.lastPathname, outletId, mustBeIonRoute, useDeprecatedRouteSetup);
    };
    const findViewItemByPathname = (pathname, outletId, useDeprecatedRouteSetup = false) => {
        return findViewItemByPath(pathname, outletId, false, useDeprecatedRouteSetup);
    };
    const findViewItemInStack = (path, stack) => {
        return stack.find((viewItem) => {
            if (viewItem.pathname === path) {
                return viewItem;
            }
            return undefined;
        });
    };
    const findViewItemByPath = (path, outletId, mustBeIonRoute = false, useDeprecatedRouteSetup = false) => {
        const matchView = (viewItem) => {
            if ((mustBeIonRoute && !viewItem.ionRoute) ||
                path === '') {
                return false;
            }
            const resolvedPath = router.resolve(path);
            let findMatchedRoute;
            // TODO: Remove in Ionic Vue v6.0
            if (useDeprecatedRouteSetup) {
                findMatchedRoute = resolvedPath.matched.find((matchedRoute) => matchedRoute === viewItem.matchedRoute && (path === viewItem.pathname || matchedRoute.path.includes(':')));
            }
            else {
                findMatchedRoute = resolvedPath.matched.find((matchedRoute) => matchedRoute === viewItem.matchedRoute);
            }
            if (findMatchedRoute) {
                return viewItem;
            }
            return undefined;
        };
        if (outletId) {
            const stack = viewStacks[outletId];
            if (!stack)
                return undefined;
            const match = (router) ? stack.find(matchView) : findViewItemInStack(path, stack);
            if (match)
                return match;
        }
        else {
            for (let outletId in viewStacks) {
                const stack = viewStacks[outletId];
                const viewItem = findViewItemInStack(path, stack);
                if (viewItem) {
                    return viewItem;
                }
            }
        }
        return undefined;
    };
    const createViewItem = (outletId, vueComponent, matchedRoute, routeInfo, ionPage) => {
        return {
            id: generateId('viewItem'),
            pathname: routeInfo.pathname,
            outletId,
            matchedRoute,
            ionPageElement: ionPage,
            vueComponent,
            vueComponentRef: shallowRef(),
            ionRoute: false,
            mount: false,
            exact: routeInfo.pathname === matchedRoute.path,
            params: routeInfo.params,
            vueComponentData: {}
        };
    };
    const add = (viewItem) => {
        const { outletId } = viewItem;
        if (!viewStacks[outletId]) {
            viewStacks[outletId] = [viewItem];
        }
        else {
            viewStacks[outletId].push(viewItem);
        }
    };
    const remove = (viewItem, outletId) => {
        if (!outletId) {
            throw Error('outletId required');
        }
        const viewStack = viewStacks[outletId];
        if (viewStack) {
            viewStacks[outletId] = viewStack.filter(item => item.id !== viewItem.id);
        }
    };
    const getChildrenToRender = (outletId) => {
        const viewStack = viewStacks[outletId];
        if (viewStack) {
            const components = viewStacks[outletId].filter(v => v.mount);
            return components;
        }
        return [];
    };
    return {
        clear,
        findViewItemByRouteInfo,
        findLeavingViewItemByRouteInfo,
        findViewItemByPathname,
        createViewItem,
        getChildrenToRender,
        add,
        remove,
        registerIonPage,
        getViewStack
    };
};

const createRouter = (opts) => {
    const routerOptions = Object.assign({}, opts);
    delete routerOptions.tabsPrefix;
    const router = createRouter$1(routerOptions);
    const ionRouter = createIonRouter(opts, router);
    const viewStacks = createViewStacks(router);
    const oldInstall = router.install.bind(router);
    router.install = (app) => {
        app.provide('navManager', ionRouter);
        app.provide('viewStacks', viewStacks);
        oldInstall(app);
    };
    const oldIsReady = router.isReady.bind(router);
    router.isReady = () => oldIsReady();
    return router;
};
const createWebHistory = (base) => createWebHistory$1(base);
const createWebHashHistory = (base) => createWebHashHistory$1(base);
const createMemoryHistory = (base) => createMemoryHistory$1(base);

export { createMemoryHistory, createRouter, createWebHashHistory, createWebHistory };
//# sourceMappingURL=index.esm.js.map
