import { addIcons } from 'ionicons';
import { arrowBackSharp, caretBackSharp, chevronBack, chevronForward, close, closeCircle, closeSharp, menuOutline, menuSharp, reorderTwoSharp, reorderThreeOutline, searchOutline, searchSharp } from 'ionicons/icons';
import { defineComponent, ref, getCurrentInstance, inject, h, computed, provide, shallowRef, watch, onUnmounted, Teleport } from 'vue';
import { setupConfig, LIFECYCLE_WILL_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_DID_ENTER, isPlatform, actionSheetController, alertController, loadingController, modalController, pickerController, popoverController, toastController } from '@ionic/core';
export { IonicSafeString, actionSheetController, alertController, createAnimation, createGesture, getPlatforms, getTimeGivenProgression, iosTransitionAnimation, isPlatform, loadingController, mdTransitionAnimation, menuController, modalController, pickerController, popoverController, toastController } from '@ionic/core';
import { applyPolyfills, defineCustomElements } from '@ionic/core/loader';
import { routeLocationKey, useRoute, matchedRouteKey } from 'vue-router';

const UPDATE_VALUE_EVENT = 'update:modelValue';
const MODEL_VALUE = 'modelValue';
const ROUTER_LINK_VALUE = 'routerLink';
const NAV_MANAGER = 'navManager';
const ROUTER_PROP_REFIX = 'router';
const getComponentClasses = (classes) => {
    var _a;
    return ((_a = classes) === null || _a === void 0 ? void 0 : _a.split(' ')) || [];
};
const getElementClasses = (ref, componentClasses, defaultClasses = []) => {
    var _a;
    return [...Array.from(((_a = ref.value) === null || _a === void 0 ? void 0 : _a.classList) || []), ...defaultClasses]
        .filter((c, i, self) => !componentClasses.has(c) && self.indexOf(c) === i);
};
/**
* Create a callback to define a Vue component wrapper around a Web Component.
*
* @prop name - The component tag name (i.e. `ion-button`)
* @prop componentProps - An array of properties on the
* component. These usually match up with the @Prop definitions
* in each component's TSX file.
* @prop componentOptions - An object that defines additional
* options for the component such as router or v-model
* integrations.
*/
const defineContainer = (name, componentProps = [], componentOptions = {}) => {
    const { modelProp, modelUpdateEvent, externalModelUpdateEvent } = componentOptions;
    /**
    * Create a Vue component wrapper around a Web Component.
    * Note: The `props` here are not all properties on a component.
    * They refer to whatever properties are set on an instance of a component.
    */
    const Container = defineComponent((props, { attrs, slots, emit }) => {
        var _a;
        let modelPropValue = props[modelProp];
        const containerRef = ref();
        const classes = new Set(getComponentClasses(attrs.class));
        const onVnodeBeforeMount = (vnode) => {
            // Add a listener to tell Vue to update the v-model
            if (vnode.el) {
                vnode.el.addEventListener(modelUpdateEvent.toLowerCase(), (e) => {
                    modelPropValue = (e === null || e === void 0 ? void 0 : e.target)[modelProp];
                    emit(UPDATE_VALUE_EVENT, modelPropValue);
                    /**
                     * We need to emit the change event here
                     * rather than on the web component to ensure
                     * that any v-model bindings have been updated.
                     * Otherwise, the developer will listen on the
                     * native web component, but the v-model will
                     * not have been updated yet.
                     */
                    emit(externalModelUpdateEvent, e);
                });
            }
        };
        const currentInstance = getCurrentInstance();
        const hasRouter = (_a = currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.appContext) === null || _a === void 0 ? void 0 : _a.provides[NAV_MANAGER];
        const navManager = hasRouter ? inject(NAV_MANAGER) : undefined;
        const handleRouterLink = (ev) => {
            const { routerLink } = props;
            if (!routerLink)
                return;
            const routerProps = Object.keys(props).filter(p => p.startsWith(ROUTER_PROP_REFIX));
            if (navManager !== undefined) {
                let navigationPayload = { event: ev };
                routerProps.forEach(prop => {
                    navigationPayload[prop] = props[prop];
                });
                navManager.navigate(navigationPayload);
            }
            else {
                console.warn('Tried to navigate, but no router was found. Make sure you have mounted Vue Router.');
            }
        };
        return () => {
            getComponentClasses(attrs.class).forEach(value => {
                classes.add(value);
            });
            const oldClick = props.onClick;
            const handleClick = (ev) => {
                if (oldClick !== undefined) {
                    oldClick(ev);
                }
                if (!ev.defaultPrevented) {
                    handleRouterLink(ev);
                }
            };
            let propsToAdd = Object.assign(Object.assign({}, props), { ref: containerRef, class: getElementClasses(containerRef, classes), onClick: handleClick, onVnodeBeforeMount: (modelUpdateEvent && externalModelUpdateEvent) ? onVnodeBeforeMount : undefined });
            if (modelProp) {
                propsToAdd = Object.assign(Object.assign({}, propsToAdd), { [modelProp]: props.hasOwnProperty('modelValue') ? props.modelValue : modelPropValue });
            }
            return h(name, propsToAdd, slots.default && slots.default());
        };
    });
    Container.displayName = name;
    Container.props = [...componentProps, ROUTER_LINK_VALUE];
    if (modelProp) {
        Container.props.push(MODEL_VALUE);
        Container.emits = [UPDATE_VALUE_EVENT, externalModelUpdateEvent];
    }
    return Container;
};

/* eslint-disable */
const IonAvatar = /*@__PURE__*/ defineContainer('ion-avatar');
const IonBackdrop = /*@__PURE__*/ defineContainer('ion-backdrop', [
    'visible',
    'tappable',
    'stopPropagation',
    'ionBackdropTap'
]);
const IonBadge = /*@__PURE__*/ defineContainer('ion-badge', [
    'color'
]);
const IonButton = /*@__PURE__*/ defineContainer('ion-button', [
    'color',
    'buttonType',
    'disabled',
    'expand',
    'fill',
    'routerDirection',
    'routerAnimation',
    'download',
    'href',
    'rel',
    'shape',
    'size',
    'strong',
    'target',
    'type',
    'ionFocus',
    'ionBlur'
]);
const IonButtons = /*@__PURE__*/ defineContainer('ion-buttons', [
    'collapse'
]);
const IonCard = /*@__PURE__*/ defineContainer('ion-card', [
    'color',
    'button',
    'type',
    'disabled',
    'download',
    'href',
    'rel',
    'routerDirection',
    'routerAnimation',
    'target'
]);
const IonCardContent = /*@__PURE__*/ defineContainer('ion-card-content');
const IonCardHeader = /*@__PURE__*/ defineContainer('ion-card-header', [
    'color',
    'translucent'
]);
const IonCardSubtitle = /*@__PURE__*/ defineContainer('ion-card-subtitle', [
    'color'
]);
const IonCardTitle = /*@__PURE__*/ defineContainer('ion-card-title', [
    'color'
]);
const IonCheckbox = /*@__PURE__*/ defineContainer('ion-checkbox', [
    'color',
    'name',
    'checked',
    'indeterminate',
    'disabled',
    'value',
    'ionChange',
    'ionFocus',
    'ionBlur',
    'ionStyle'
], {
    "modelProp": "checked",
    "modelUpdateEvent": "v-ionChange",
    "externalModelUpdateEvent": "ionChange"
});
const IonChip = /*@__PURE__*/ defineContainer('ion-chip', [
    'color',
    'outline',
    'disabled'
]);
const IonCol = /*@__PURE__*/ defineContainer('ion-col', [
    'offset',
    'offsetXs',
    'offsetSm',
    'offsetMd',
    'offsetLg',
    'offsetXl',
    'pull',
    'pullXs',
    'pullSm',
    'pullMd',
    'pullLg',
    'pullXl',
    'push',
    'pushXs',
    'pushSm',
    'pushMd',
    'pushLg',
    'pushXl',
    'size',
    'sizeXs',
    'sizeSm',
    'sizeMd',
    'sizeLg',
    'sizeXl'
]);
const IonContent = /*@__PURE__*/ defineContainer('ion-content', [
    'color',
    'fullscreen',
    'forceOverscroll',
    'scrollX',
    'scrollY',
    'scrollEvents',
    'ionScrollStart',
    'ionScroll',
    'ionScrollEnd'
]);
const IonDatetime = /*@__PURE__*/ defineContainer('ion-datetime', [
    'name',
    'disabled',
    'readonly',
    'min',
    'max',
    'displayFormat',
    'displayTimezone',
    'pickerFormat',
    'cancelText',
    'doneText',
    'yearValues',
    'monthValues',
    'dayValues',
    'hourValues',
    'minuteValues',
    'monthNames',
    'monthShortNames',
    'dayNames',
    'dayShortNames',
    'pickerOptions',
    'placeholder',
    'value',
    'ionCancel',
    'ionChange',
    'ionFocus',
    'ionBlur',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": "v-ionChange",
    "externalModelUpdateEvent": "ionChange"
});
const IonFab = /*@__PURE__*/ defineContainer('ion-fab', [
    'horizontal',
    'vertical',
    'edge',
    'activated'
]);
const IonFabButton = /*@__PURE__*/ defineContainer('ion-fab-button', [
    'color',
    'activated',
    'disabled',
    'download',
    'href',
    'rel',
    'routerDirection',
    'routerAnimation',
    'target',
    'show',
    'translucent',
    'type',
    'size',
    'closeIcon',
    'ionFocus',
    'ionBlur'
]);
const IonFabList = /*@__PURE__*/ defineContainer('ion-fab-list', [
    'activated',
    'side'
]);
const IonFooter = /*@__PURE__*/ defineContainer('ion-footer', [
    'translucent'
]);
const IonGrid = /*@__PURE__*/ defineContainer('ion-grid', [
    'fixed'
]);
const IonHeader = /*@__PURE__*/ defineContainer('ion-header', [
    'collapse',
    'translucent'
]);
const IonImg = /*@__PURE__*/ defineContainer('ion-img', [
    'alt',
    'src',
    'ionImgWillLoad',
    'ionImgDidLoad',
    'ionError'
]);
const IonInfiniteScroll = /*@__PURE__*/ defineContainer('ion-infinite-scroll', [
    'threshold',
    'disabled',
    'position',
    'ionInfinite'
]);
const IonInfiniteScrollContent = /*@__PURE__*/ defineContainer('ion-infinite-scroll-content', [
    'loadingSpinner',
    'loadingText'
]);
const IonInput = /*@__PURE__*/ defineContainer('ion-input', [
    'fireFocusEvents',
    'color',
    'accept',
    'autocapitalize',
    'autocomplete',
    'autocorrect',
    'autofocus',
    'clearInput',
    'clearOnEdit',
    'debounce',
    'disabled',
    'enterkeyhint',
    'inputmode',
    'max',
    'maxlength',
    'min',
    'minlength',
    'multiple',
    'name',
    'pattern',
    'placeholder',
    'readonly',
    'required',
    'spellcheck',
    'step',
    'size',
    'type',
    'value',
    'ionInput',
    'ionChange',
    'ionBlur',
    'ionFocus',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": "v-ionChange",
    "externalModelUpdateEvent": "ionChange"
});
const IonItem = /*@__PURE__*/ defineContainer('ion-item', [
    'color',
    'button',
    'detail',
    'detailIcon',
    'disabled',
    'download',
    'href',
    'rel',
    'lines',
    'routerAnimation',
    'routerDirection',
    'target',
    'type'
]);
const IonItemDivider = /*@__PURE__*/ defineContainer('ion-item-divider', [
    'color',
    'sticky'
]);
const IonItemGroup = /*@__PURE__*/ defineContainer('ion-item-group');
const IonItemOption = /*@__PURE__*/ defineContainer('ion-item-option', [
    'color',
    'disabled',
    'download',
    'expandable',
    'href',
    'rel',
    'target',
    'type'
]);
const IonItemOptions = /*@__PURE__*/ defineContainer('ion-item-options', [
    'side',
    'ionSwipe'
]);
const IonItemSliding = /*@__PURE__*/ defineContainer('ion-item-sliding', [
    'disabled',
    'ionDrag'
]);
const IonLabel = /*@__PURE__*/ defineContainer('ion-label', [
    'color',
    'position',
    'ionColor',
    'ionStyle'
]);
const IonList = /*@__PURE__*/ defineContainer('ion-list', [
    'lines',
    'inset'
]);
const IonListHeader = /*@__PURE__*/ defineContainer('ion-list-header', [
    'color',
    'lines'
]);
const IonMenu = /*@__PURE__*/ defineContainer('ion-menu', [
    'contentId',
    'menuId',
    'type',
    'disabled',
    'side',
    'swipeGesture',
    'maxEdgeStart',
    'ionWillOpen',
    'ionWillClose',
    'ionDidOpen',
    'ionDidClose',
    'ionMenuChange'
]);
const IonMenuButton = /*@__PURE__*/ defineContainer('ion-menu-button', [
    'color',
    'disabled',
    'menu',
    'autoHide',
    'type'
]);
const IonMenuToggle = /*@__PURE__*/ defineContainer('ion-menu-toggle', [
    'menu',
    'autoHide'
]);
const IonNavLink = /*@__PURE__*/ defineContainer('ion-nav-link', [
    'component',
    'componentProps',
    'routerDirection',
    'routerAnimation'
]);
const IonNote = /*@__PURE__*/ defineContainer('ion-note', [
    'color'
]);
const IonProgressBar = /*@__PURE__*/ defineContainer('ion-progress-bar', [
    'type',
    'reversed',
    'value',
    'buffer',
    'color'
]);
const IonRadio = /*@__PURE__*/ defineContainer('ion-radio', [
    'color',
    'name',
    'disabled',
    'value',
    'ionStyle',
    'ionFocus',
    'ionBlur'
], {
    "modelProp": "value",
    "modelUpdateEvent": "v-ionChange",
    "externalModelUpdateEvent": "ionChange"
});
const IonRadioGroup = /*@__PURE__*/ defineContainer('ion-radio-group', [
    'allowEmptySelection',
    'name',
    'value',
    'ionChange'
], {
    "modelProp": "value",
    "modelUpdateEvent": "v-ionChange",
    "externalModelUpdateEvent": "ionChange"
});
const IonRange = /*@__PURE__*/ defineContainer('ion-range', [
    'color',
    'debounce',
    'name',
    'dualKnobs',
    'min',
    'max',
    'pin',
    'snaps',
    'step',
    'ticks',
    'disabled',
    'value',
    'ionChange',
    'ionStyle',
    'ionFocus',
    'ionBlur'
], {
    "modelProp": "value",
    "modelUpdateEvent": "v-ionChange",
    "externalModelUpdateEvent": "ionChange"
});
const IonRefresher = /*@__PURE__*/ defineContainer('ion-refresher', [
    'pullMin',
    'pullMax',
    'closeDuration',
    'snapbackDuration',
    'pullFactor',
    'disabled',
    'ionRefresh',
    'ionPull',
    'ionStart'
]);
const IonRefresherContent = /*@__PURE__*/ defineContainer('ion-refresher-content', [
    'pullingIcon',
    'pullingText',
    'refreshingSpinner',
    'refreshingText'
]);
const IonReorder = /*@__PURE__*/ defineContainer('ion-reorder');
const IonReorderGroup = /*@__PURE__*/ defineContainer('ion-reorder-group', [
    'disabled',
    'ionItemReorder'
]);
const IonRippleEffect = /*@__PURE__*/ defineContainer('ion-ripple-effect', [
    'type'
]);
const IonRow = /*@__PURE__*/ defineContainer('ion-row');
const IonSearchbar = /*@__PURE__*/ defineContainer('ion-searchbar', [
    'color',
    'animated',
    'autocomplete',
    'autocorrect',
    'cancelButtonIcon',
    'cancelButtonText',
    'clearIcon',
    'debounce',
    'disabled',
    'inputmode',
    'enterkeyhint',
    'placeholder',
    'searchIcon',
    'showCancelButton',
    'spellcheck',
    'type',
    'value',
    'ionInput',
    'ionChange',
    'ionCancel',
    'ionClear',
    'ionBlur',
    'ionFocus',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": "v-ionChange",
    "externalModelUpdateEvent": "ionChange"
});
const IonSegment = /*@__PURE__*/ defineContainer('ion-segment', [
    'color',
    'disabled',
    'scrollable',
    'swipeGesture',
    'value',
    'ionChange',
    'ionSelect',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": "v-ionChange",
    "externalModelUpdateEvent": "ionChange"
});
const IonSegmentButton = /*@__PURE__*/ defineContainer('ion-segment-button', [
    'disabled',
    'layout',
    'type',
    'value'
], {
    "modelProp": "value",
    "modelUpdateEvent": "v-ionChange",
    "externalModelUpdateEvent": "ionChange"
});
const IonSelect = /*@__PURE__*/ defineContainer('ion-select', [
    'disabled',
    'cancelText',
    'okText',
    'placeholder',
    'name',
    'selectedText',
    'multiple',
    'interface',
    'interfaceOptions',
    'compareWith',
    'value',
    'ionChange',
    'ionCancel',
    'ionFocus',
    'ionBlur',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": "v-ionChange",
    "externalModelUpdateEvent": "ionChange"
});
const IonSelectOption = /*@__PURE__*/ defineContainer('ion-select-option', [
    'disabled',
    'value'
]);
const IonSkeletonText = /*@__PURE__*/ defineContainer('ion-skeleton-text', [
    'animated'
]);
const IonSlide = /*@__PURE__*/ defineContainer('ion-slide');
const IonSlides = /*@__PURE__*/ defineContainer('ion-slides', [
    'options',
    'pager',
    'scrollbar',
    'ionSlidesDidLoad',
    'ionSlideTap',
    'ionSlideDoubleTap',
    'ionSlideWillChange',
    'ionSlideDidChange',
    'ionSlideNextStart',
    'ionSlidePrevStart',
    'ionSlideNextEnd',
    'ionSlidePrevEnd',
    'ionSlideTransitionStart',
    'ionSlideTransitionEnd',
    'ionSlideDrag',
    'ionSlideReachStart',
    'ionSlideReachEnd',
    'ionSlideTouchStart',
    'ionSlideTouchEnd'
]);
const IonSpinner = /*@__PURE__*/ defineContainer('ion-spinner', [
    'color',
    'duration',
    'name',
    'paused'
]);
const IonSplitPane = /*@__PURE__*/ defineContainer('ion-split-pane', [
    'contentId',
    'disabled',
    'when',
    'ionSplitPaneVisible'
]);
const IonText = /*@__PURE__*/ defineContainer('ion-text', [
    'color'
]);
const IonTextarea = /*@__PURE__*/ defineContainer('ion-textarea', [
    'fireFocusEvents',
    'color',
    'autocapitalize',
    'autofocus',
    'clearOnEdit',
    'debounce',
    'disabled',
    'inputmode',
    'enterkeyhint',
    'maxlength',
    'minlength',
    'name',
    'placeholder',
    'readonly',
    'required',
    'spellcheck',
    'cols',
    'rows',
    'wrap',
    'autoGrow',
    'value',
    'ionChange',
    'ionInput',
    'ionStyle',
    'ionBlur',
    'ionFocus'
], {
    "modelProp": "value",
    "modelUpdateEvent": "v-ionChange",
    "externalModelUpdateEvent": "ionChange"
});
const IonThumbnail = /*@__PURE__*/ defineContainer('ion-thumbnail');
const IonTitle = /*@__PURE__*/ defineContainer('ion-title', [
    'color',
    'size',
    'ionStyle'
]);
const IonToggle = /*@__PURE__*/ defineContainer('ion-toggle', [
    'color',
    'name',
    'checked',
    'disabled',
    'value',
    'ionChange',
    'ionFocus',
    'ionBlur',
    'ionStyle'
], {
    "modelProp": "checked",
    "modelUpdateEvent": "v-ionChange",
    "externalModelUpdateEvent": "ionChange"
});
const IonToolbar = /*@__PURE__*/ defineContainer('ion-toolbar', [
    'color'
]);
const IonVirtualScroll = /*@__PURE__*/ defineContainer('ion-virtual-scroll', [
    'approxItemHeight',
    'approxHeaderHeight',
    'approxFooterHeight',
    'headerFn',
    'footerFn',
    'items',
    'itemHeight',
    'headerHeight',
    'footerHeight',
    'renderItem',
    'renderHeader',
    'renderFooter',
    'nodeRender',
    'domRender'
]);

/**
 * We need to make sure that the web component fires an event
 * that will not conflict with the user's @ionChange binding,
 * otherwise the binding's callback will fire before any
 * v-model values have been updated.
 */
const transformEventName = (eventName) => {
    return eventName === 'ionChange' ? 'v-ionchange' : eventName.toLowerCase();
};
const ael = (el, eventName, cb, opts) => el.addEventListener(transformEventName(eventName), cb, opts);
const rel = (el, eventName, cb, opts) => el.removeEventListener(transformEventName(eventName), cb, opts);
const IonicVue = {
    async install(_app, config = {}) {
        if (typeof window !== 'undefined') {
            setupConfig(Object.assign(Object.assign({}, config), { _ael: ael, _rel: rel }));
            await applyPolyfills();
            await defineCustomElements(window, {
                exclude: ['ion-tabs'],
                ce: (eventName, opts) => new CustomEvent(transformEventName(eventName), opts),
                ael,
                rel
            });
        }
    }
};

const IonBackButton = defineComponent({
    name: 'IonBackButton',
    setup(_, { attrs, slots }) {
        const ionRouter = inject('navManager');
        const onClick = () => {
            const defaultHref = attrs['default-href'] || attrs['defaultHref'];
            const routerAnimation = attrs['router-animation'] || attrs['routerAnimation'];
            ionRouter.handleNavigateBack(defaultHref, routerAnimation);
        };
        return () => {
            return h('ion-back-button', Object.assign({ onClick }, attrs), slots.default && slots.default());
        };
    }
});

const IonPage = defineComponent({
    name: 'IonPage',
    props: {
        isInOutlet: { type: Boolean, default: false },
        registerIonPage: { type: Function, default: () => { } }
    },
    mounted() {
        this.$props.registerIonPage(this.$refs.ionPage);
    },
    setup(props, { attrs, slots }) {
        const hidePageClass = (props.isInOutlet) ? 'ion-page-invisible' : '';
        return () => {
            return h('div', Object.assign(Object.assign({ ['class']: `ion-page ${hidePageClass}` }, attrs), { ref: 'ionPage' }), slots.default && slots.default());
        };
    }
});

const ids = { main: 0 };
const generateId = (type = 'main') => {
    var _a;
    const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;
    ids[type] = id;
    return (id).toString();
};
// TODO types
const fireLifecycle = (vueComponent, vueInstance, lifecycle) => {
    if (vueComponent === null || vueComponent === void 0 ? void 0 : vueComponent[lifecycle]) {
        vueComponent[lifecycle].bind(vueInstance === null || vueInstance === void 0 ? void 0 : vueInstance.value)();
    }
    const instance = vueInstance === null || vueInstance === void 0 ? void 0 : vueInstance.value;
    if (instance === null || instance === void 0 ? void 0 : instance[lifecycle]) {
        instance[lifecycle]();
    }
};
const getConfig = () => {
    if (typeof window !== 'undefined') {
        const Ionic = window.Ionic;
        if (Ionic && Ionic.config) {
            return Ionic.config;
        }
    }
    return null;
};

let viewDepthKey = Symbol(0);
const IonRouterOutlet = defineComponent({
    name: 'IonRouterOutlet',
    setup(_, { attrs }) {
        var _a, _b;
        const injectedRoute = inject(routeLocationKey);
        const route = useRoute();
        const depth = inject(viewDepthKey, 0);
        let usingDeprecatedRouteSetup = false;
        // TODO: Remove in Ionic Vue v6.0
        if (attrs.tabs && ((_b = (_a = route.matched[depth]) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.length) > 0) {
            console.warn('[@ionic/vue Deprecation]: Your child routes are nested inside of each tab in your routing config. This format will not be supported in Ionic Vue v6.0. Instead, write your child routes as sibling routes. See https://ionicframework.com/docs/vue/navigation#child-routes-within-tabs for more information.');
            usingDeprecatedRouteSetup = true;
        }
        const matchedRouteRef = computed(() => {
            const matchedRoute = route.matched[depth];
            if (matchedRoute && attrs.tabs && route.matched[depth + 1] && usingDeprecatedRouteSetup) {
                return route.matched[route.matched.length - 1];
            }
            return matchedRoute;
        });
        provide(viewDepthKey, depth + 1);
        provide(matchedRouteKey, matchedRouteRef);
        const ionRouterOutlet = ref();
        const id = generateId('ion-router-outlet');
        // TODO types
        const ionRouter = inject('navManager');
        const viewStacks = inject('viewStacks');
        const components = shallowRef([]);
        let skipTransition = false;
        // The base url for this router outlet
        let parentOutletPath;
        watch(matchedRouteRef, (currentValue, previousValue) => {
            /**
             * We need to make sure that we are not re-rendering
             * the same view if navigation changes in a sub-outlet.
             * This is mainly for tabs when outlet 1 renders ion-tabs
             * and outlet 2 renders the individual tab view. We don't
             * want outlet 1 creating a new ion-tabs instance every time
             * we switch tabs.
             */
            if (currentValue !== previousValue) {
                setupViewItem(matchedRouteRef);
            }
        });
        const canStart = () => {
            const config = getConfig();
            const swipeEnabled = config && config.get('swipeBackEnabled', ionRouterOutlet.value.mode === 'ios');
            if (!swipeEnabled)
                return false;
            const stack = viewStacks.getViewStack(id);
            if (!stack || stack.length <= 1)
                return false;
            /**
             * We only want to outlet of the entering view
             * to respond to this gesture, so check
             * to make sure the view is in the outlet we want.
             */
            const routeInfo = ionRouter.getCurrentRouteInfo();
            const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute || '' }, id, usingDeprecatedRouteSetup);
            return !!enteringViewItem;
        };
        const onStart = async () => {
            const routeInfo = ionRouter.getCurrentRouteInfo();
            const { routerAnimation } = routeInfo;
            const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute || '' }, id, usingDeprecatedRouteSetup);
            const leavingViewItem = viewStacks.findViewItemByRouteInfo(routeInfo, id, usingDeprecatedRouteSetup);
            if (leavingViewItem) {
                let animationBuilder = routerAnimation;
                const enteringEl = enteringViewItem.ionPageElement;
                const leavingEl = leavingViewItem.ionPageElement;
                /**
                * If we are going back from a page that
                * was presented using a custom animation
                * we should default to using that
                * unless the developer explicitly
                * provided another animation.
                */
                const customAnimation = enteringViewItem.routerAnimation;
                if (animationBuilder === undefined &&
                    // todo check for tab switch
                    customAnimation !== undefined) {
                    animationBuilder = customAnimation;
                }
                leavingViewItem.routerAnimation = animationBuilder;
                await transition(enteringEl, leavingEl, 'back', ionRouter.canGoBack(2), true, animationBuilder);
            }
            return Promise.resolve();
        };
        const onEnd = (shouldContinue) => {
            if (shouldContinue) {
                skipTransition = true;
                /**
                 * Use the same logic as clicking
                 * ion-back-button to determine where
                 * to go back to.
                 */
                ionRouter.handleNavigateBack();
            }
            else {
                /**
                 * In the event that the swipe
                 * gesture was aborted, we should
                 * re-hide the page that was going to enter.
                 */
                const routeInfo = ionRouter.getCurrentRouteInfo();
                const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute || '' }, id, usingDeprecatedRouteSetup);
                enteringViewItem.ionPageElement.setAttribute('aria-hidden', 'true');
                enteringViewItem.ionPageElement.classList.add('ion-page-hidden');
            }
        };
        watch(ionRouterOutlet, () => {
            ionRouterOutlet.value.swipeHandler = {
                canStart,
                onStart,
                onEnd
            };
        });
        const transition = (enteringEl, leavingEl, direction, // TODO types
        showGoBack, progressAnimation, animationBuilder) => {
            return new Promise(resolve => {
                if (skipTransition) {
                    skipTransition = false;
                    return resolve(false);
                }
                if (enteringEl === leavingEl) {
                    return resolve(false);
                }
                requestAnimationFrame(() => {
                    requestAnimationFrame(async () => {
                        enteringEl.classList.add('ion-page-invisible');
                        const result = await ionRouterOutlet.value.commit(enteringEl, leavingEl, {
                            deepWait: true,
                            duration: direction === undefined || direction === 'root' || direction === 'none' ? 0 : undefined,
                            direction,
                            showGoBack,
                            progressAnimation,
                            animationBuilder
                        });
                        return resolve(result);
                    });
                });
            });
        };
        const handlePageTransition = async () => {
            const routeInfo = ionRouter.getCurrentRouteInfo();
            const { routerDirection, routerAction, routerAnimation, prevRouteLastPathname } = routeInfo;
            const enteringViewItem = viewStacks.findViewItemByRouteInfo(routeInfo, id, usingDeprecatedRouteSetup);
            let leavingViewItem = viewStacks.findLeavingViewItemByRouteInfo(routeInfo, id, true, usingDeprecatedRouteSetup);
            const enteringEl = enteringViewItem.ionPageElement;
            if (enteringViewItem === leavingViewItem)
                return;
            if (!leavingViewItem && prevRouteLastPathname) {
                leavingViewItem = viewStacks.findViewItemByPathname(prevRouteLastPathname, id, usingDeprecatedRouteSetup);
            }
            fireLifecycle(enteringViewItem.vueComponent, enteringViewItem.vueComponentRef, LIFECYCLE_WILL_ENTER);
            if (leavingViewItem && enteringViewItem !== leavingViewItem) {
                let animationBuilder = routerAnimation;
                const leavingEl = leavingViewItem.ionPageElement;
                fireLifecycle(leavingViewItem.vueComponent, leavingViewItem.vueComponentRef, LIFECYCLE_WILL_LEAVE);
                /**
                * If we are going back from a page that
                * was presented using a custom animation
                * we should default to using that
                * unless the developer explicitly
                * provided another animation.
                */
                const customAnimation = enteringViewItem.routerAnimation;
                if (animationBuilder === undefined &&
                    routerDirection === 'back' &&
                    // todo check for tab switch
                    customAnimation !== undefined) {
                    animationBuilder = customAnimation;
                }
                leavingViewItem.routerAnimation = animationBuilder;
                await transition(enteringEl, leavingEl, routerDirection, !!routeInfo.pushedByRoute, false, animationBuilder);
                leavingEl.classList.add('ion-page-hidden');
                leavingEl.setAttribute('aria-hidden', 'true');
                if (routerAction === 'replace') {
                    leavingViewItem.mount = false;
                    leavingViewItem.ionPageElement = undefined;
                    leavingViewItem.ionRoute = false;
                }
                else if (!(routerAction === 'push' && routerDirection === 'forward')) {
                    const shouldLeavingViewBeRemoved = routerDirection !== 'none' && leavingViewItem && (enteringViewItem !== leavingViewItem);
                    if (shouldLeavingViewBeRemoved) {
                        leavingViewItem.mount = false;
                        leavingViewItem.ionPageElement = undefined;
                        leavingViewItem.ionRoute = false;
                    }
                }
                fireLifecycle(leavingViewItem.vueComponent, leavingViewItem.vueComponentRef, LIFECYCLE_DID_LEAVE);
            }
            else {
                /**
                 * If there is no leaving element, just show
                 * the entering element. Wrap it in an raf
                 * in case ion-content's fullscreen callback
                 * is running. Otherwise we'd have a flicker.
                 */
                requestAnimationFrame(() => enteringEl.classList.remove('ion-page-invisible'));
            }
            fireLifecycle(enteringViewItem.vueComponent, enteringViewItem.vueComponentRef, LIFECYCLE_DID_ENTER);
            components.value = viewStacks.getChildrenToRender(id);
        };
        const setupViewItem = (matchedRouteRef) => {
            const firstMatchedRoute = route.matched[0];
            if (!parentOutletPath) {
                parentOutletPath = firstMatchedRoute.path;
            }
            /**
             * If no matched route, do not do anything in this outlet.
             * If there is a match, but it the first matched path
             * is not the root path for this outlet, then this view
             * change needs to be rendered in a different outlet.
             * We also add an exception for when the matchedRouteRef is
             * equal to the first matched route (i.e. the base router outlet).
             * This logic is mainly to help nested outlets/multi-tab
             * setups work better.
             */
            if (!matchedRouteRef.value ||
                (matchedRouteRef.value !== firstMatchedRoute && firstMatchedRoute.path !== parentOutletPath)) {
                return;
            }
            const currentRoute = ionRouter.getCurrentRouteInfo();
            let enteringViewItem = viewStacks.findViewItemByRouteInfo(currentRoute, id, usingDeprecatedRouteSetup);
            if (!enteringViewItem) {
                enteringViewItem = viewStacks.createViewItem(id, matchedRouteRef.value.components.default, matchedRouteRef.value, currentRoute);
                viewStacks.add(enteringViewItem);
            }
            if (!enteringViewItem.mount) {
                enteringViewItem.mount = true;
                enteringViewItem.registerCallback = () => {
                    handlePageTransition();
                    enteringViewItem.registerCallback = undefined;
                };
            }
            else {
                handlePageTransition();
            }
            components.value = viewStacks.getChildrenToRender(id);
        };
        if (matchedRouteRef.value) {
            setupViewItem(matchedRouteRef);
        }
        /**
         * Remove stack data for this outlet
         * when outlet is destroyed otherwise
         * we will see cached view data.
         */
        onUnmounted(() => viewStacks.clear(id));
        // TODO types
        const registerIonPage = (viewItem, ionPageEl) => {
            const oldIonPageEl = viewItem.ionPageElement;
            viewStacks.registerIonPage(viewItem, ionPageEl);
            /**
             * If there is a registerCallback,
             * then this component is being registered
             * as a result of a navigation change.
             */
            if (viewItem.registerCallback) {
                viewItem.registerCallback();
                /**
                 * If there is no registerCallback, then
                 * this component is likely being re-registered
                 * as a result of a hot module replacement.
                 * We need to see if the oldIonPageEl has
                 * .ion-page-invisible. If it does not then we
                 * need to remove it from the new ionPageEl otherwise
                 * the page will be hidden when it is replaced.
                 */
            }
            else if (oldIonPageEl && !oldIonPageEl.classList.contains('ion-page-invisible')) {
                ionPageEl.classList.remove('ion-page-invisible');
            }
        };
        return {
            id,
            components,
            injectedRoute,
            ionRouterOutlet,
            registerIonPage
        };
    },
    render() {
        const { components, registerIonPage, injectedRoute } = this;
        return h('ion-router-outlet', { ref: 'ionRouterOutlet' }, 
        // TODO types
        components && components.map((c) => {
            var _a, _b;
            let props = {
                ref: c.vueComponentRef,
                key: c.pathname,
                isInOutlet: true,
                registerIonPage: (ionPageEl) => registerIonPage(c, ionPageEl)
            };
            /**
             * IonRouterOutlet does not support named outlets.
             */
            const routePropsOption = (_b = (_a = c.matchedRoute) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.default;
            /**
             * Since IonRouterOutlet renders multiple components,
             * each render will cause all props functions to be
             * called again. As a result, we need to cache the function
             * result and provide it on each render so that the props
             * are not lost when navigating from and back to a page.
             * When a component is destroyed and re-created, the
             * function is called again.
             */
            const getPropsFunctionResult = () => {
                var _a;
                const cachedPropsResult = (_a = c.vueComponentData) === null || _a === void 0 ? void 0 : _a.propsFunctionResult;
                if (cachedPropsResult) {
                    return cachedPropsResult;
                }
                else {
                    const propsFunctionResult = routePropsOption(injectedRoute);
                    c.vueComponentData = Object.assign(Object.assign({}, c.vueComponentData), { propsFunctionResult });
                    return propsFunctionResult;
                }
            };
            const routeProps = routePropsOption
                ? routePropsOption === true
                    ? c.params
                    : typeof routePropsOption === 'function'
                        ? getPropsFunctionResult()
                        : routePropsOption
                : null;
            props = Object.assign(Object.assign({}, props), routeProps);
            return h(c.vueComponent, props);
        }));
    }
});

const IonTabButton = defineComponent({
    name: 'IonTabButton',
    props: {
        _getTabState: { type: Function, default: () => { return {}; } },
        disabled: Boolean,
        download: String,
        href: String,
        rel: String,
        layout: String,
        selected: Boolean,
        tab: String,
        target: String
    },
    setup(props, { slots }) {
        const ionRouter = inject('navManager');
        const onClick = (ev) => {
            if (ev.cancelable) {
                ev.preventDefault();
            }
            /**
             * Keeping track of the originalHref
             * (i.e. /tabs/tab1) lets us redirect
             * users back to a child page using currentHref
             * (i.e. /tabs/tab1/child).
             */
            const { tab, href, _getTabState } = props;
            const tabState = _getTabState();
            const tappedTab = tabState.tabs[tab] || {};
            const originalHref = tappedTab.originalHref || href;
            const currentHref = tappedTab.currentHref || href;
            const prevActiveTab = tabState.activeTab;
            /**
             * If we are still on the same
             * tab as before, but the base href
             * does not equal the current href,
             * then we must be on a child page and
             * should direct users back to the root
             * of the tab.
             */
            if (prevActiveTab === tab) {
                if (originalHref !== currentHref) {
                    ionRouter.resetTab(tab, originalHref);
                }
            }
            else {
                ionRouter.changeTab(tab, currentHref);
            }
        };
        return () => {
            return h('ion-tab-button', Object.assign({ onClick }, props), slots.default && slots.default());
        };
    }
});

const WILL_CHANGE = 'ionTabsWillChange';
const DID_CHANGE = 'ionTabsDidChange';
const IonTabs = defineComponent({
    name: 'IonTabs',
    emits: [WILL_CHANGE, DID_CHANGE],
    render() {
        var _a;
        const { $slots: slots, $emit } = this;
        const slottedContent = slots.default && slots.default();
        let childrenToRender = [
            h('div', {
                class: 'tabs-inner',
                style: {
                    'position': 'relative',
                    'flex': '1',
                    'contain': 'layout size style'
                }
            }, [
                h(IonRouterOutlet, { tabs: true })
            ])
        ];
        /**
         * If ion-tab-bar has slot="top" it needs to be
         * rendered before `.tabs-inner` otherwise it will
         * not show above the tab content.
         */
        if (slottedContent && slottedContent.length > 0) {
            const slottedTabBar = slottedContent.find((child) => child.type && child.type.name === 'IonTabBar');
            const hasTopSlotTabBar = slottedTabBar && ((_a = slottedTabBar.props) === null || _a === void 0 ? void 0 : _a.slot) === 'top';
            if (slottedTabBar) {
                if (!slottedTabBar.props) {
                    slottedTabBar.props = {};
                }
                /**
                 * ionTabsWillChange and ionTabsDidChange are
                 * fired from `ion-tabs`, so we need to pass these down
                 * as props so they can fire when the active tab changes.
                 * TODO: We may want to move logic from the tab bar into here
                 * so we do not have code split across two components.
                 */
                slottedTabBar.props._tabsWillChange = (tab) => $emit(WILL_CHANGE, { tab });
                slottedTabBar.props._tabsDidChange = (tab) => $emit(DID_CHANGE, { tab });
            }
            if (hasTopSlotTabBar) {
                childrenToRender = [
                    ...slottedContent,
                    ...childrenToRender
                ];
            }
            else {
                childrenToRender = [
                    ...childrenToRender,
                    ...slottedContent
                ];
            }
        }
        return h('ion-tabs', {
            style: {
                'display': 'flex',
                'position': 'absolute',
                'top': '0',
                'left': '0',
                'right': '0',
                'bottom': '0',
                'flex-direction': 'column',
                'width': '100%',
                'height': '100%',
                'contain': 'layout size style',
                'z-index': '0'
            }
        }, childrenToRender);
    }
});

const IonTabBar = defineComponent({
    name: 'IonTabBar',
    props: {
        _tabsWillChange: { type: Function, default: () => { } },
        _tabsDidChange: { type: Function, default: () => { } }
    },
    mounted() {
        const ionRouter = inject('navManager');
        const tabState = {
            activeTab: undefined,
            tabs: {}
        };
        const currentInstance = getCurrentInstance();
        const isTabButton = (child) => { var _a; return ((_a = child.type) === null || _a === void 0 ? void 0 : _a.name) === 'IonTabButton'; };
        /**
         * For each tab, we need to keep track of its
         * base href as well as any child page that
         * is active in its stack so that when we go back
         * to a tab from another tab, we can correctly
         * show any child pages if necessary.
         */
        const children = (currentInstance.subTree.children || []);
        children.forEach((child) => {
            if (isTabButton(child)) {
                tabState.tabs[child.props.tab] = {
                    originalHref: child.props.href,
                    currentHref: child.props.href,
                    ref: child
                };
                /**
                 * Passing this prop to each tab button
                 * lets it be aware of the state that
                 * ion-tab-bar is managing for it.
                 */
                child.component.props._getTabState = () => tabState;
            }
        });
        const checkActiveTab = (currentRoute) => {
            const childNodes = (currentInstance.subTree.children || []);
            const { tabs, activeTab: prevActiveTab } = tabState;
            const tabKeys = Object.keys(tabs);
            const activeTab = tabKeys
                .find(key => {
                const href = tabs[key].originalHref;
                return currentRoute.pathname.startsWith(href);
            });
            /**
             * For each tab, check to see if the
             * base href has changed. If so, update
             * it in the tabs state.
             */
            childNodes.forEach((child) => {
                if (isTabButton(child)) {
                    const tab = tabs[child.props.tab];
                    if (!tab || (tab.originalHref !== child.props.href)) {
                        tabs[child.props.tab] = {
                            originalHref: child.props.href,
                            currentHref: child.props.href,
                            ref: child
                        };
                    }
                }
            });
            if (activeTab && prevActiveTab) {
                const prevHref = tabState.tabs[prevActiveTab].currentHref;
                /**
                 * If the tabs change or the url changes,
                 * update the currentHref for the active tab.
                 * Ex: url changes from /tabs/tab1 --> /tabs/tab1/child
                 * If we went to tab2 then back to tab1, we should
                 * land on /tabs/tab1/child instead of /tabs/tab1.
                 */
                if (activeTab !== prevActiveTab || (prevHref !== currentRoute.pathname)) {
                    tabs[activeTab] = Object.assign(Object.assign({}, tabs[activeTab]), { currentHref: currentRoute.pathname + (currentRoute.search || '') });
                }
                /**
                 * If navigating back and the tabs change,
                 * set the previous tab back to its original href.
                 */
                if (currentRoute.routerAction === 'pop' && (activeTab !== prevActiveTab)) {
                    tabs[prevActiveTab] = Object.assign(Object.assign({}, tabs[prevActiveTab]), { currentHref: tabs[prevActiveTab].originalHref });
                }
            }
            const activeChild = childNodes.find((child) => { var _a; return isTabButton(child) && ((_a = child.props) === null || _a === void 0 ? void 0 : _a.tab) === activeTab; });
            const tabBar = this.$refs.ionTabBar;
            const tabDidChange = activeTab !== prevActiveTab;
            if (activeChild && tabBar) {
                tabDidChange && this.$props._tabsWillChange(activeTab);
                ionRouter.handleSetCurrentTab(activeTab);
                tabBar.selectedTab = tabState.activeTab = activeTab;
                tabDidChange && this.$props._tabsDidChange(activeTab);
            }
        };
        ionRouter.registerHistoryChangeListener(checkActiveTab.bind(this));
        checkActiveTab(ionRouter.getCurrentRouteInfo());
    },
    setup(_, { slots }) {
        return () => {
            return h('ion-tab-bar', { ref: 'ionTabBar' }, slots.default && slots.default());
        };
    }
});

const userComponents = shallowRef([]);
const IonApp = defineComponent({
    name: 'IonApp',
    setup(_, { attrs, slots }) {
        return () => {
            return h('ion-app', Object.assign({}, attrs), [slots.default && slots.default(), ...userComponents.value]);
        };
    }
});
/**
 * When rendering user components inside of
 * ion-modal, ion-popover, or ion-nav, the component
 * needs to be created inside of the current application
 * context otherwise libraries such as vue-i18n or vuex
 * will not work properly.
 *
 * `userComponents` renders teleported components as children
 * of `ion-app` within the current application context.
 */
const addTeleportedUserComponent = (component) => {
    userComponents.value = [
        ...userComponents.value,
        component
    ];
};
const removeTeleportedUserComponent = (component) => {
    userComponents.value = userComponents.value.filter(cmp => cmp !== component);
};

const VueDelegate = () => {
    let Component;
    const attachViewToDom = (parentElement, component, componentProps = {}, classes) => {
        /**
         * Ionic Framework passes in modal and popover element
         * refs as props, but if these are not defined
         * on the Vue component instance as props, Vue will
         * warn the user.
         */
        delete componentProps['modal'];
        delete componentProps['popover'];
        const div = document.createElement('div');
        classes && div.classList.add(...classes);
        parentElement.appendChild(div);
        Component = h(Teleport, { to: div }, h(component, Object.assign({}, componentProps)));
        addTeleportedUserComponent(Component);
        return div;
    };
    const removeViewFromDom = () => {
        Component && removeTeleportedUserComponent(Component);
        return Promise.resolve();
    };
    return { attachViewToDom, removeViewFromDom };
};

const IonNav = defineComponent({
    name: 'IonNav',
    setup(_, { slots }) {
        const delegate = VueDelegate();
        return () => {
            return h('ion-nav', { delegate }, slots);
        };
    }
});

const IonIcon = defineComponent({
    name: 'IonIcon',
    props: {
        ariaLabel: String,
        color: String,
        flipRtl: Boolean,
        icon: String,
        ios: String,
        lazy: String,
        md: String,
        mode: String,
        name: String,
        size: String,
        src: String
    },
    setup(props, { slots }) {
        return () => {
            var _a, _b;
            const { icon, ios, md } = props;
            let iconToUse;
            if (ios || md) {
                if (isPlatform('ios')) {
                    iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md) !== null && _a !== void 0 ? _a : icon;
                }
                else {
                    iconToUse = (_b = md !== null && md !== void 0 ? md : ios) !== null && _b !== void 0 ? _b : icon;
                }
            }
            else {
                iconToUse = icon;
            }
            return h('ion-icon', Object.assign(Object.assign({}, props), { icon: iconToUse }), slots);
        };
    }
});

const defineOverlayContainer = (name, componentProps = [], controller) => {
    // TODO
    const eventPrefix = name.toLowerCase().split('-').join('');
    const eventListeners = [
        { componentEv: `${eventPrefix}willpresent`, frameworkEv: 'onWillPresent' },
        { componentEv: `${eventPrefix}didpresent`, frameworkEv: 'onDidPresent' },
        { componentEv: `${eventPrefix}willdismiss`, frameworkEv: 'onWillDismiss' },
        { componentEv: `${eventPrefix}diddismiss`, frameworkEv: 'onDidDismiss' },
    ];
    const Container = defineComponent((props, { slots, emit }) => {
        const overlay = ref();
        const onVnodeMounted = async () => {
            const isOpen = props.isOpen;
            isOpen && (await present(props));
        };
        const onVnodeUpdated = async () => {
            var _a, _b;
            const isOpen = props.isOpen;
            if (isOpen) {
                await ((_a = overlay.value) === null || _a === void 0 ? void 0 : _a.present()) || present(props);
            }
            else {
                await ((_b = overlay.value) === null || _b === void 0 ? void 0 : _b.dismiss());
                overlay.value = undefined;
            }
        };
        const onVnodeBeforeUnmount = async () => {
            var _a;
            await ((_a = overlay.value) === null || _a === void 0 ? void 0 : _a.dismiss());
            overlay.value = undefined;
        };
        const present = async (props) => {
            const component = slots.default && slots.default()[0];
            overlay.value = await controller.create(Object.assign(Object.assign({}, props), { component }));
            eventListeners.forEach(eventListener => {
                overlay.value.addEventListener(eventListener.componentEv, () => {
                    emit(eventListener.frameworkEv);
                });
            });
            await overlay.value.present();
        };
        return () => {
            return h('div', {
                style: { display: 'none' },
                onVnodeMounted,
                onVnodeUpdated,
                onVnodeBeforeUnmount
            });
        };
    });
    Container.displayName = name;
    Container.props = [...componentProps, 'isOpen'];
    Container.emits = eventListeners.map(ev => ev.frameworkEv);
    return Container;
};

/* auto-generated vue overlay proxies */
const IonActionSheet = /*@__PURE__*/ defineOverlayContainer('ion-action-sheet', ['animated', 'backdropDismiss', 'buttons', 'cssClass', 'enterAnimation', 'header', 'keyboardClose', 'leaveAnimation', 'mode', 'subHeader', 'translucent'], actionSheetController);
const IonAlert = /*@__PURE__*/ defineOverlayContainer('ion-alert', ['animated', 'backdropDismiss', 'buttons', 'cssClass', 'enterAnimation', 'header', 'inputs', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'subHeader', 'translucent'], alertController);
const IonLoading = /*@__PURE__*/ defineOverlayContainer('ion-loading', ['animated', 'backdropDismiss', 'cssClass', 'duration', 'enterAnimation', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'showBackdrop', 'spinner', 'translucent'], loadingController);
const IonModal = /*@__PURE__*/ defineOverlayContainer('ion-modal', ['animated', 'backdropDismiss', 'component', 'componentProps', 'cssClass', 'enterAnimation', 'keyboardClose', 'leaveAnimation', 'mode', 'presentingElement', 'showBackdrop', 'swipeToClose'], modalController);
const IonPicker = /*@__PURE__*/ defineOverlayContainer('ion-picker', ['animated', 'backdropDismiss', 'buttons', 'columns', 'cssClass', 'duration', 'enterAnimation', 'keyboardClose', 'leaveAnimation', 'mode', 'showBackdrop'], pickerController);
const IonPopover = /*@__PURE__*/ defineOverlayContainer('ion-popover', ['animated', 'backdropDismiss', 'component', 'componentProps', 'cssClass', 'enterAnimation', 'event', 'keyboardClose', 'leaveAnimation', 'mode', 'showBackdrop', 'translucent'], popoverController);
const IonToast = /*@__PURE__*/ defineOverlayContainer('ion-toast', ['animated', 'buttons', 'color', 'cssClass', 'duration', 'enterAnimation', 'header', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'position', 'translucent'], toastController);

const useBackButton = (priority, handler) => {
    const callback = (ev) => ev.detail.register(priority, handler);
    const unregister = () => document.removeEventListener('ionBackButton', callback);
    document.addEventListener('ionBackButton', callback);
    return { unregister };
};
const useIonRouter = () => {
    const { canGoBack } = inject('navManager');
    return {
        canGoBack
    };
};
const useKeyboard = () => {
    let isOpen = ref(false);
    let keyboardHeight = ref(0);
    const showCallback = (ev) => {
        isOpen.value = true;
        keyboardHeight.value = ev.detail.keyboardHeight;
    };
    const hideCallback = () => {
        isOpen.value = false;
        keyboardHeight.value = 0;
    };
    const unregister = () => {
        if (typeof window !== 'undefined') {
            window.removeEventListener('ionKeyboardDidShow', showCallback);
            window.removeEventListener('ionKeyboardDidHide', hideCallback);
        }
    };
    if (typeof window !== 'undefined') {
        window.addEventListener('ionKeyboardDidShow', showCallback);
        window.addEventListener('ionKeyboardDidHide', hideCallback);
    }
    return {
        isOpen,
        keyboardHeight,
        unregister
    };
};

const oldModalCreate = modalController.create.bind(modalController);
modalController.create = (options) => {
    return oldModalCreate(Object.assign(Object.assign({}, options), { delegate: VueDelegate() }));
};
const oldPopoverCreate = popoverController.create.bind(popoverController);
popoverController.create = (options) => {
    return oldPopoverCreate(Object.assign(Object.assign({}, options), { delegate: VueDelegate() }));
};

// Icons that are used by internal components
addIcons({
    'arrow-back-sharp': arrowBackSharp,
    'caret-back-sharp': caretBackSharp,
    'chevron-back': chevronBack,
    'chevron-forward': chevronForward,
    'close': close,
    'close-circle': closeCircle,
    'close-sharp': closeSharp,
    'menu-outline': menuOutline,
    'menu-sharp': menuSharp,
    'reorder-two-sharp': reorderTwoSharp,
    'reorder-three-outline': reorderThreeOutline,
    'search-outline': searchOutline,
    'search-sharp': searchSharp,
});

export { IonActionSheet, IonAlert, IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonLoading, IonMenu, IonMenuButton, IonMenuToggle, IonModal, IonNav, IonNavLink, IonNote, IonPage, IonPicker, IonPopover, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonTabs, IonText, IonTextarea, IonThumbnail, IonTitle, IonToast, IonToggle, IonToolbar, IonVirtualScroll, IonicVue, useBackButton, useIonRouter, useKeyboard };
//# sourceMappingURL=index.esm.js.map
