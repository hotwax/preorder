
/**
 * @vue/test-utils v2.0.0-rc.1
 * (c) 2021 Lachlan Miller
 * Released under the MIT License
 */

var VueTestUtils = (function (exports, vue, compilerDom) {
    'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var vue__namespace = /*#__PURE__*/_interopNamespace(vue);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    var Pluggable = /** @class */ (function () {
        function Pluggable() {
            this.installedPlugins = [];
        }
        Pluggable.prototype.install = function (handler, options) {
            if (typeof handler !== 'function') {
                console.error('plugin.install must receive a function');
                handler = function () { return ({}); };
            }
            this.installedPlugins.push({ handler: handler, options: options });
        };
        Pluggable.prototype.extend = function (instance) {
            var invokeSetup = function (_a) {
                var handler = _a.handler, options = _a.options;
                return handler(instance, options); // invoke the setup method passed to install
            };
            var bindProperty = function (_a) {
                var property = _a[0], value = _a[1];
                instance[property] =
                    typeof value === 'function' ? value.bind(instance) : value;
            };
            var addAllPropertiesFromSetup = function (setupResult) {
                setupResult = typeof setupResult === 'object' ? setupResult : {};
                Object.entries(setupResult).forEach(bindProperty);
            };
            this.installedPlugins.map(invokeSetup).forEach(addAllPropertiesFromSetup);
        };
        /** For testing */
        Pluggable.prototype.reset = function () {
            this.installedPlugins = [];
        };
        return Pluggable;
    }());
    var config = {
        global: {
            stubs: {
                transition: true,
                'transition-group': true
            },
            provide: {},
            components: {},
            config: {},
            directives: {},
            mixins: [],
            mocks: {},
            plugins: [],
            renderStubDefaultSlot: false
        },
        plugins: {
            VueWrapper: new Pluggable(),
            DOMWrapper: new Pluggable()
        },
        renderStubDefaultSlot: false
    };

    function mergeStubs(target, source) {
        if (source.stubs) {
            if (Array.isArray(source.stubs)) {
                source.stubs.forEach(function (x) { return (target[x] = true); });
            }
            else {
                for (var _i = 0, _a = Object.entries(source.stubs); _i < _a.length; _i++) {
                    var _b = _a[_i], k = _b[0], v = _b[1];
                    target[k] = v;
                }
            }
        }
    }
    function mergeGlobalProperties(configGlobal, mountGlobal) {
        if (configGlobal === void 0) { configGlobal = {}; }
        if (mountGlobal === void 0) { mountGlobal = {}; }
        var stubs = {};
        mergeStubs(stubs, configGlobal);
        mergeStubs(stubs, mountGlobal);
        return {
            mixins: __spreadArrays((configGlobal.mixins || []), (mountGlobal.mixins || [])),
            plugins: __spreadArrays((configGlobal.plugins || []), (mountGlobal.plugins || [])),
            stubs: stubs,
            components: __assign(__assign({}, configGlobal.components), mountGlobal.components),
            provide: __assign(__assign({}, configGlobal.provide), mountGlobal.provide),
            mocks: __assign(__assign({}, configGlobal.mocks), mountGlobal.mocks),
            config: __assign(__assign({}, configGlobal.config), mountGlobal.config),
            directives: __assign(__assign({}, configGlobal.directives), mountGlobal.directives)
        };
    }
    // https://stackoverflow.com/a/48218209
    var mergeDeep = function (target, source) {
        var isObject = function (obj) {
            return !!obj && typeof obj === 'object';
        };
        if (!isObject(target) || !isObject(source)) {
            return source;
        }
        Object.keys(source).forEach(function (key) {
            var targetValue = target[key];
            var sourceValue = source[key];
            if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
                target[key] = targetValue.concat(sourceValue);
            }
            else if (isObject(targetValue) && isObject(sourceValue)) {
                target[key] = mergeDeep(Object.assign({}, targetValue), sourceValue);
            }
            else {
                target[key] = sourceValue;
            }
        });
        return target;
    };
    function isClassComponent(component) {
        // TypeScript
        return (component.toString().includes('_super.apply(this, arguments) || this') ||
            // native ES6
            (typeof component === 'function' &&
                /^\s*class\s+/.test(component.toString())));
    }
    function isFunctionalComponent(component) {
        return typeof component === 'function' && !isClassComponent(component);
    }
    function isObjectComponent(component) {
        return typeof component !== 'function' && !isClassComponent(component);
    }
    // https://stackoverflow.com/questions/15458876/check-if-a-string-is-html-or-not/15458987#answer-15458968
    function isHTML(str) {
        var a = document.createElement('div');
        a.innerHTML = str;
        for (var c = a.childNodes, i = c.length; i--;) {
            if (c[i].nodeType == 1) {
                return true;
            }
        }
        return false;
    }
    function textContent(element) {
        var _a, _b;
        // we check if the element is a comment first
        // to return an empty string in that case, instead of the comment content
        return element.nodeType !== Node.COMMENT_NODE
            ? (_b = (_a = element.textContent) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : '' : '';
    }

    function processSlot(source, Vue) {
        if (source === void 0) { source = ''; }
        if (Vue === void 0) { Vue = vue__namespace; }
        var template = source.trim();
        var hasWrappingTemplate = template && template.startsWith('<template');
        // allow content without `template` tag, for easier testing
        if (!hasWrappingTemplate) {
            template = "<template #default=\"params\">" + template + "</template>";
        }
        var code = compilerDom.compile("<SlotWrapper v-bind=\"$attrs\">" + template + "</SlotWrapper>", {
            mode: 'function',
            prefixIdentifiers: true
        }).code;
        var createRenderFunction = new Function('Vue', "'use strict';\n" + code);
        return {
            inheritAttrs: false,
            render: createRenderFunction(Vue),
            components: {
                SlotWrapper: {
                    inheritAttrs: false,
                    setup: function (_, ctx) {
                        return function () {
                            var names = Object.keys(ctx.slots);
                            if (names.length === 0) {
                                return [];
                            }
                            else {
                                var slotName = names[0];
                                return ctx.slots[slotName](ctx.attrs);
                            }
                        };
                    }
                }
            }
        };
    }

    function createWrapperError(wrapperType) {
        return new Proxy(Object.create(null), {
            get: function (obj, prop) {
                switch (prop) {
                    case 'exists':
                        return function () { return false; };
                    default:
                        throw new Error("Cannot call " + String(prop) + " on an empty " + wrapperType + ".");
                }
            }
        });
    }

    var abort = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var afterprint = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var animationend = {
    	eventInterface: "AnimationEvent",
    	bubbles: true,
    	cancelable: false
    };
    var animationiteration = {
    	eventInterface: "AnimationEvent",
    	bubbles: true,
    	cancelable: false
    };
    var animationstart = {
    	eventInterface: "AnimationEvent",
    	bubbles: true,
    	cancelable: false
    };
    var appinstalled = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var audioprocess = {
    	eventInterface: "AudioProcessingEvent"
    };
    var audioend = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var audiostart = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var beforeprint = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var beforeunload = {
    	eventInterface: "BeforeUnloadEvent",
    	bubbles: false,
    	cancelable: true
    };
    var beginEvent = {
    	eventInterface: "TimeEvent",
    	bubbles: false,
    	cancelable: false
    };
    var blur = {
    	eventInterface: "FocusEvent",
    	bubbles: false,
    	cancelable: false
    };
    var boundary = {
    	eventInterface: "SpeechSynthesisEvent",
    	bubbles: false,
    	cancelable: false
    };
    var cached = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var canplay = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var canplaythrough = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var change = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var chargingchange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var chargingtimechange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var checking = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var click = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var close = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var complete = {
    	eventInterface: "OfflineAudioCompletionEvent"
    };
    var compositionend = {
    	eventInterface: "CompositionEvent",
    	bubbles: true,
    	cancelable: true
    };
    var compositionstart = {
    	eventInterface: "CompositionEvent",
    	bubbles: true,
    	cancelable: true
    };
    var compositionupdate = {
    	eventInterface: "CompositionEvent",
    	bubbles: true,
    	cancelable: false
    };
    var contextmenu = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var copy = {
    	eventInterface: "ClipboardEvent"
    };
    var cut = {
    	eventInterface: "ClipboardEvent",
    	bubbles: true,
    	cancelable: true
    };
    var dblclick = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var devicechange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var devicelight = {
    	eventInterface: "DeviceLightEvent",
    	bubbles: false,
    	cancelable: false
    };
    var devicemotion = {
    	eventInterface: "DeviceMotionEvent",
    	bubbles: false,
    	cancelable: false
    };
    var deviceorientation = {
    	eventInterface: "DeviceOrientationEvent",
    	bubbles: false,
    	cancelable: false
    };
    var deviceproximity = {
    	eventInterface: "DeviceProximityEvent",
    	bubbles: false,
    	cancelable: false
    };
    var dischargingtimechange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var DOMActivate = {
    	eventInterface: "UIEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMAttributeNameChanged = {
    	eventInterface: "MutationNameEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMAttrModified = {
    	eventInterface: "MutationEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMCharacterDataModified = {
    	eventInterface: "MutationEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMContentLoaded = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: true
    };
    var DOMElementNameChanged = {
    	eventInterface: "MutationNameEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMFocusIn = {
    	eventInterface: "FocusEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMFocusOut = {
    	eventInterface: "FocusEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMNodeInserted = {
    	eventInterface: "MutationEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMNodeInsertedIntoDocument = {
    	eventInterface: "MutationEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMNodeRemoved = {
    	eventInterface: "MutationEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMNodeRemovedFromDocument = {
    	eventInterface: "MutationEvent",
    	bubbles: true,
    	cancelable: true
    };
    var DOMSubtreeModified = {
    	eventInterface: "MutationEvent"
    };
    var downloading = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var drag = {
    	eventInterface: "DragEvent",
    	bubbles: true,
    	cancelable: true
    };
    var dragend = {
    	eventInterface: "DragEvent",
    	bubbles: true,
    	cancelable: false
    };
    var dragenter = {
    	eventInterface: "DragEvent",
    	bubbles: true,
    	cancelable: true
    };
    var dragleave = {
    	eventInterface: "DragEvent",
    	bubbles: true,
    	cancelable: false
    };
    var dragover = {
    	eventInterface: "DragEvent",
    	bubbles: true,
    	cancelable: true
    };
    var dragstart = {
    	eventInterface: "DragEvent",
    	bubbles: true,
    	cancelable: true
    };
    var drop = {
    	eventInterface: "DragEvent",
    	bubbles: true,
    	cancelable: true
    };
    var durationchange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var emptied = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var end = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var ended = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var endEvent = {
    	eventInterface: "TimeEvent",
    	bubbles: false,
    	cancelable: false
    };
    var error = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var focus = {
    	eventInterface: "FocusEvent",
    	bubbles: false,
    	cancelable: false
    };
    var focusin = {
    	eventInterface: "FocusEvent",
    	bubbles: true,
    	cancelable: false
    };
    var focusout = {
    	eventInterface: "FocusEvent",
    	bubbles: true,
    	cancelable: false
    };
    var fullscreenchange = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var fullscreenerror = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var gamepadconnected = {
    	eventInterface: "GamepadEvent",
    	bubbles: false,
    	cancelable: false
    };
    var gamepaddisconnected = {
    	eventInterface: "GamepadEvent",
    	bubbles: false,
    	cancelable: false
    };
    var gotpointercapture = {
    	eventInterface: "PointerEvent",
    	bubbles: false,
    	cancelable: false
    };
    var hashchange = {
    	eventInterface: "HashChangeEvent",
    	bubbles: true,
    	cancelable: false
    };
    var lostpointercapture = {
    	eventInterface: "PointerEvent",
    	bubbles: false,
    	cancelable: false
    };
    var input = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var invalid = {
    	eventInterface: "Event",
    	cancelable: true,
    	bubbles: false
    };
    var keydown = {
    	eventInterface: "KeyboardEvent",
    	bubbles: true,
    	cancelable: true
    };
    var keypress = {
    	eventInterface: "KeyboardEvent",
    	bubbles: true,
    	cancelable: true
    };
    var keyup = {
    	eventInterface: "KeyboardEvent",
    	bubbles: true,
    	cancelable: true
    };
    var languagechange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var levelchange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var load = {
    	eventInterface: "UIEvent",
    	bubbles: false,
    	cancelable: false
    };
    var loadeddata = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var loadedmetadata = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var loadend = {
    	eventInterface: "ProgressEvent",
    	bubbles: false,
    	cancelable: false
    };
    var loadstart = {
    	eventInterface: "ProgressEvent",
    	bubbles: false,
    	cancelable: false
    };
    var mark = {
    	eventInterface: "SpeechSynthesisEvent",
    	bubbles: false,
    	cancelable: false
    };
    var message = {
    	eventInterface: "MessageEvent",
    	bubbles: false,
    	cancelable: false
    };
    var messageerror = {
    	eventInterface: "MessageEvent",
    	bubbles: false,
    	cancelable: false
    };
    var mousedown = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var mouseenter = {
    	eventInterface: "MouseEvent",
    	bubbles: false,
    	cancelable: false
    };
    var mouseleave = {
    	eventInterface: "MouseEvent",
    	bubbles: false,
    	cancelable: false
    };
    var mousemove = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var mouseout = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var mouseover = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var mouseup = {
    	eventInterface: "MouseEvent",
    	bubbles: true,
    	cancelable: true
    };
    var nomatch = {
    	eventInterface: "SpeechRecognitionEvent",
    	bubbles: false,
    	cancelable: false
    };
    var notificationclick = {
    	eventInterface: "NotificationEvent",
    	bubbles: false,
    	cancelable: false
    };
    var noupdate = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var obsolete = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var offline = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var online = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var open = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var orientationchange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var pagehide = {
    	eventInterface: "PageTransitionEvent",
    	bubbles: false,
    	cancelable: false
    };
    var pageshow = {
    	eventInterface: "PageTransitionEvent",
    	bubbles: false,
    	cancelable: false
    };
    var paste = {
    	eventInterface: "ClipboardEvent",
    	bubbles: true,
    	cancelable: true
    };
    var pause = {
    	eventInterface: "SpeechSynthesisEvent",
    	bubbles: false,
    	cancelable: false
    };
    var pointercancel = {
    	eventInterface: "PointerEvent",
    	bubbles: true,
    	cancelable: false
    };
    var pointerdown = {
    	eventInterface: "PointerEvent",
    	bubbles: true,
    	cancelable: true
    };
    var pointerenter = {
    	eventInterface: "PointerEvent",
    	bubbles: false,
    	cancelable: false
    };
    var pointerleave = {
    	eventInterface: "PointerEvent",
    	bubbles: false,
    	cancelable: false
    };
    var pointerlockchange = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var pointerlockerror = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var pointermove = {
    	eventInterface: "PointerEvent",
    	bubbles: true,
    	cancelable: true
    };
    var pointerout = {
    	eventInterface: "PointerEvent",
    	bubbles: true,
    	cancelable: true
    };
    var pointerover = {
    	eventInterface: "PointerEvent",
    	bubbles: true,
    	cancelable: true
    };
    var pointerup = {
    	eventInterface: "PointerEvent",
    	bubbles: true,
    	cancelable: true
    };
    var play = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var playing = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var popstate = {
    	eventInterface: "PopStateEvent",
    	bubbles: true,
    	cancelable: false
    };
    var progress = {
    	eventInterface: "ProgressEvent",
    	bubbles: false,
    	cancelable: false
    };
    var push = {
    	eventInterface: "PushEvent",
    	bubbles: false,
    	cancelable: false
    };
    var pushsubscriptionchange = {
    	eventInterface: "PushEvent",
    	bubbles: false,
    	cancelable: false
    };
    var ratechange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var readystatechange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var repeatEvent = {
    	eventInterface: "TimeEvent",
    	bubbles: false,
    	cancelable: false
    };
    var reset = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: true
    };
    var resize = {
    	eventInterface: "UIEvent",
    	bubbles: false,
    	cancelable: false
    };
    var resourcetimingbufferfull = {
    	eventInterface: "Performance",
    	bubbles: true,
    	cancelable: true
    };
    var result = {
    	eventInterface: "SpeechRecognitionEvent",
    	bubbles: false,
    	cancelable: false
    };
    var resume = {
    	eventInterface: "SpeechSynthesisEvent",
    	bubbles: false,
    	cancelable: false
    };
    var scroll = {
    	eventInterface: "UIEvent",
    	bubbles: false,
    	cancelable: false
    };
    var seeked = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var seeking = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var select = {
    	eventInterface: "UIEvent",
    	bubbles: true,
    	cancelable: false
    };
    var selectstart = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: true
    };
    var selectionchange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var show = {
    	eventInterface: "MouseEvent",
    	bubbles: false,
    	cancelable: false
    };
    var slotchange = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var soundend = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var soundstart = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var speechend = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var speechstart = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var stalled = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var start = {
    	eventInterface: "SpeechSynthesisEvent",
    	bubbles: false,
    	cancelable: false
    };
    var storage = {
    	eventInterface: "StorageEvent",
    	bubbles: false,
    	cancelable: false
    };
    var submit = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: true
    };
    var success = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var suspend = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var SVGAbort = {
    	eventInterface: "SVGEvent",
    	bubbles: true,
    	cancelable: false
    };
    var SVGError = {
    	eventInterface: "SVGEvent",
    	bubbles: true,
    	cancelable: false
    };
    var SVGLoad = {
    	eventInterface: "SVGEvent",
    	bubbles: false,
    	cancelable: false
    };
    var SVGResize = {
    	eventInterface: "SVGEvent",
    	bubbles: true,
    	cancelable: false
    };
    var SVGScroll = {
    	eventInterface: "SVGEvent",
    	bubbles: true,
    	cancelable: false
    };
    var SVGUnload = {
    	eventInterface: "SVGEvent",
    	bubbles: false,
    	cancelable: false
    };
    var SVGZoom = {
    	eventInterface: "SVGZoomEvent",
    	bubbles: true,
    	cancelable: false
    };
    var timeout = {
    	eventInterface: "ProgressEvent",
    	bubbles: false,
    	cancelable: false
    };
    var timeupdate = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var touchcancel = {
    	eventInterface: "TouchEvent",
    	bubbles: true,
    	cancelable: false
    };
    var touchend = {
    	eventInterface: "TouchEvent",
    	bubbles: true,
    	cancelable: true
    };
    var touchmove = {
    	eventInterface: "TouchEvent",
    	bubbles: true,
    	cancelable: true
    };
    var touchstart = {
    	eventInterface: "TouchEvent",
    	bubbles: true,
    	cancelable: true
    };
    var transitionend = {
    	eventInterface: "TransitionEvent",
    	bubbles: true,
    	cancelable: true
    };
    var unload = {
    	eventInterface: "UIEvent",
    	bubbles: false
    };
    var updateready = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var userproximity = {
    	eventInterface: "UserProximityEvent",
    	bubbles: false,
    	cancelable: false
    };
    var voiceschanged = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var visibilitychange = {
    	eventInterface: "Event",
    	bubbles: true,
    	cancelable: false
    };
    var volumechange = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var waiting = {
    	eventInterface: "Event",
    	bubbles: false,
    	cancelable: false
    };
    var wheel = {
    	eventInterface: "WheelEvent",
    	bubbles: true,
    	cancelable: true
    };
    var require$$0 = {
    	abort: abort,
    	afterprint: afterprint,
    	animationend: animationend,
    	animationiteration: animationiteration,
    	animationstart: animationstart,
    	appinstalled: appinstalled,
    	audioprocess: audioprocess,
    	audioend: audioend,
    	audiostart: audiostart,
    	beforeprint: beforeprint,
    	beforeunload: beforeunload,
    	beginEvent: beginEvent,
    	blur: blur,
    	boundary: boundary,
    	cached: cached,
    	canplay: canplay,
    	canplaythrough: canplaythrough,
    	change: change,
    	chargingchange: chargingchange,
    	chargingtimechange: chargingtimechange,
    	checking: checking,
    	click: click,
    	close: close,
    	complete: complete,
    	compositionend: compositionend,
    	compositionstart: compositionstart,
    	compositionupdate: compositionupdate,
    	contextmenu: contextmenu,
    	copy: copy,
    	cut: cut,
    	dblclick: dblclick,
    	devicechange: devicechange,
    	devicelight: devicelight,
    	devicemotion: devicemotion,
    	deviceorientation: deviceorientation,
    	deviceproximity: deviceproximity,
    	dischargingtimechange: dischargingtimechange,
    	DOMActivate: DOMActivate,
    	DOMAttributeNameChanged: DOMAttributeNameChanged,
    	DOMAttrModified: DOMAttrModified,
    	DOMCharacterDataModified: DOMCharacterDataModified,
    	DOMContentLoaded: DOMContentLoaded,
    	DOMElementNameChanged: DOMElementNameChanged,
    	DOMFocusIn: DOMFocusIn,
    	DOMFocusOut: DOMFocusOut,
    	DOMNodeInserted: DOMNodeInserted,
    	DOMNodeInsertedIntoDocument: DOMNodeInsertedIntoDocument,
    	DOMNodeRemoved: DOMNodeRemoved,
    	DOMNodeRemovedFromDocument: DOMNodeRemovedFromDocument,
    	DOMSubtreeModified: DOMSubtreeModified,
    	downloading: downloading,
    	drag: drag,
    	dragend: dragend,
    	dragenter: dragenter,
    	dragleave: dragleave,
    	dragover: dragover,
    	dragstart: dragstart,
    	drop: drop,
    	durationchange: durationchange,
    	emptied: emptied,
    	end: end,
    	ended: ended,
    	endEvent: endEvent,
    	error: error,
    	focus: focus,
    	focusin: focusin,
    	focusout: focusout,
    	fullscreenchange: fullscreenchange,
    	fullscreenerror: fullscreenerror,
    	gamepadconnected: gamepadconnected,
    	gamepaddisconnected: gamepaddisconnected,
    	gotpointercapture: gotpointercapture,
    	hashchange: hashchange,
    	lostpointercapture: lostpointercapture,
    	input: input,
    	invalid: invalid,
    	keydown: keydown,
    	keypress: keypress,
    	keyup: keyup,
    	languagechange: languagechange,
    	levelchange: levelchange,
    	load: load,
    	loadeddata: loadeddata,
    	loadedmetadata: loadedmetadata,
    	loadend: loadend,
    	loadstart: loadstart,
    	mark: mark,
    	message: message,
    	messageerror: messageerror,
    	mousedown: mousedown,
    	mouseenter: mouseenter,
    	mouseleave: mouseleave,
    	mousemove: mousemove,
    	mouseout: mouseout,
    	mouseover: mouseover,
    	mouseup: mouseup,
    	nomatch: nomatch,
    	notificationclick: notificationclick,
    	noupdate: noupdate,
    	obsolete: obsolete,
    	offline: offline,
    	online: online,
    	open: open,
    	orientationchange: orientationchange,
    	pagehide: pagehide,
    	pageshow: pageshow,
    	paste: paste,
    	pause: pause,
    	pointercancel: pointercancel,
    	pointerdown: pointerdown,
    	pointerenter: pointerenter,
    	pointerleave: pointerleave,
    	pointerlockchange: pointerlockchange,
    	pointerlockerror: pointerlockerror,
    	pointermove: pointermove,
    	pointerout: pointerout,
    	pointerover: pointerover,
    	pointerup: pointerup,
    	play: play,
    	playing: playing,
    	popstate: popstate,
    	progress: progress,
    	push: push,
    	pushsubscriptionchange: pushsubscriptionchange,
    	ratechange: ratechange,
    	readystatechange: readystatechange,
    	repeatEvent: repeatEvent,
    	reset: reset,
    	resize: resize,
    	resourcetimingbufferfull: resourcetimingbufferfull,
    	result: result,
    	resume: resume,
    	scroll: scroll,
    	seeked: seeked,
    	seeking: seeking,
    	select: select,
    	selectstart: selectstart,
    	selectionchange: selectionchange,
    	show: show,
    	slotchange: slotchange,
    	soundend: soundend,
    	soundstart: soundstart,
    	speechend: speechend,
    	speechstart: speechstart,
    	stalled: stalled,
    	start: start,
    	storage: storage,
    	submit: submit,
    	success: success,
    	suspend: suspend,
    	SVGAbort: SVGAbort,
    	SVGError: SVGError,
    	SVGLoad: SVGLoad,
    	SVGResize: SVGResize,
    	SVGScroll: SVGScroll,
    	SVGUnload: SVGUnload,
    	SVGZoom: SVGZoom,
    	timeout: timeout,
    	timeupdate: timeupdate,
    	touchcancel: touchcancel,
    	touchend: touchend,
    	touchmove: touchmove,
    	touchstart: touchstart,
    	transitionend: transitionend,
    	unload: unload,
    	updateready: updateready,
    	userproximity: userproximity,
    	voiceschanged: voiceschanged,
    	visibilitychange: visibilitychange,
    	volumechange: volumechange,
    	waiting: waiting,
    	wheel: wheel
    };

    var domEventTypes = require$$0;

    var keyCodesByKeyName = {
        backspace: 8,
        tab: 9,
        enter: 13,
        esc: 27,
        space: 32,
        pageup: 33,
        pagedown: 34,
        end: 35,
        home: 36,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        insert: 45,
        delete: 46
    };
    // modifiers to keep an eye on
    var ignorableKeyModifiers = ['stop', 'prevent', 'self', 'exact'];
    var systemKeyModifiers = ['ctrl', 'shift', 'alt', 'meta'];
    var mouseKeyModifiers = ['left', 'middle', 'right'];
    /**
     * Groups modifiers into lists
     */
    function generateModifiers(modifiers, isOnClick) {
        var keyModifiers = [];
        var systemModifiers = [];
        for (var i = 0; i < modifiers.length; i++) {
            var modifier = modifiers[i];
            // addEventListener() options, e.g. .passive & .capture, that we dont need to handle
            if (ignorableKeyModifiers.includes(modifier)) {
                continue;
            }
            // modifiers that require special conversion
            // if passed a left/right key modifier with onClick, add it here as well.
            if (systemKeyModifiers.includes(modifier) ||
                (mouseKeyModifiers.includes(modifier) &&
                    isOnClick)) {
                systemModifiers.push(modifier);
            }
            else {
                keyModifiers.push(modifier);
            }
        }
        return {
            keyModifiers: keyModifiers,
            systemModifiers: systemModifiers
        };
    }
    function getEventProperties(eventParams) {
        var modifiers = eventParams.modifiers, _a = eventParams.options, options = _a === void 0 ? {} : _a, eventType = eventParams.eventType;
        var isOnClick = eventType === 'click';
        var _b = generateModifiers(modifiers, isOnClick), keyModifiers = _b.keyModifiers, systemModifiers = _b.systemModifiers;
        if (isOnClick) {
            // if it's a right click, it should fire a `contextmenu` event
            if (systemModifiers.includes('right')) {
                eventType = 'contextmenu';
                options.button = 2;
                // if its a middle click, fire a `mouseup` event
            }
            else if (systemModifiers.includes('middle')) {
                eventType = 'mouseup';
                options.button = 1;
            }
        }
        var meta = domEventTypes[eventType] || {
            eventInterface: 'Event',
            cancelable: true,
            bubbles: true
        };
        // convert `shift, ctrl` to `shiftKey, ctrlKey`
        // allows trigger('keydown.shift.ctrl.n') directly
        var systemModifiersMeta = systemModifiers.reduce(function (all, key) {
            all[key + "Key"] = true;
            return all;
        }, {});
        // get the keyCode for backwards compat
        var keyCode = keyCodesByKeyName[keyModifiers[0]] ||
            (options && (options.keyCode || options.code));
        var eventProperties = __assign(__assign(__assign(__assign({}, systemModifiersMeta), options), { bubbles: meta.bubbles, cancelable: meta.cancelable, 
            // Any derived options should go here
            keyCode: keyCode, code: keyCode }), (keyModifiers[0] ? { key: keyModifiers[0] } : {}));
        return {
            eventProperties: eventProperties,
            meta: meta,
            eventType: eventType
        };
    }
    function createEvent(eventParams) {
        var _a = getEventProperties(eventParams), eventProperties = _a.eventProperties, meta = _a.meta, eventType = _a.eventType;
        // user defined eventInterface
        var metaEventInterface = window[meta.eventInterface];
        var SupportedEventInterface = typeof metaEventInterface === 'function' ? metaEventInterface : window.Event;
        return new SupportedEventInterface(eventType, 
        // event properties can only be added when the event is instantiated
        // custom properties must be added after the event has been instantiated
        eventProperties);
    }
    function createDOMEvent(eventString, options) {
        // split eventString like `keydown.ctrl.shift.c` into `keydown` and array of modifiers
        var _a = eventString.split('.'), eventType = _a[0], modifiers = _a.slice(1);
        var eventParams = {
            eventType: eventType,
            modifiers: modifiers,
            options: options
        };
        var event = createEvent(eventParams);
        var eventPrototype = Object.getPrototypeOf(event);
        // attach custom options to the event, like `relatedTarget` and so on.
        options &&
            Object.keys(options).forEach(function (key) {
                var propertyDescriptor = Object.getOwnPropertyDescriptor(eventPrototype, key);
                var canSetProperty = !(propertyDescriptor && propertyDescriptor.set === undefined);
                if (canSetProperty) {
                    event[key] = options[key];
                }
            });
        return event;
    }

    /*!
     * isElementVisible
     * Adapted from https://github.com/testing-library/jest-dom
     * Licensed under the MIT License.
     */
    function isStyleVisible(element) {
        if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) {
            return false;
        }
        var _a = element.style, display = _a.display, visibility = _a.visibility, opacity = _a.opacity;
        return (display !== 'none' &&
            visibility !== 'hidden' &&
            visibility !== 'collapse' &&
            opacity !== '0');
    }
    function isAttributeVisible(element) {
        return (!element.hasAttribute('hidden') &&
            (element.nodeName === 'DETAILS' ? element.hasAttribute('open') : true));
    }
    function isElementVisible(element) {
        return (element.nodeName !== '#comment' &&
            isStyleVisible(element) &&
            isAttributeVisible(element) &&
            (!element.parentElement || isElementVisible(element.parentElement)));
    }

    var DOMWrapper = /** @class */ (function () {
        function DOMWrapper(element) {
            this.element = element;
            // plugins hook
            config.plugins.DOMWrapper.extend(this);
        }
        DOMWrapper.prototype.classes = function (className) {
            var classes = this.element.classList;
            if (className)
                return classes.contains(className);
            return Array.from(classes);
        };
        DOMWrapper.prototype.attributes = function (key) {
            var attributes = Array.from(this.element.attributes);
            var attributeMap = {};
            for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
                var attribute = attributes_1[_i];
                attributeMap[attribute.localName] = attribute.value;
            }
            return key ? attributeMap[key] : attributeMap;
        };
        DOMWrapper.prototype.exists = function () {
            return true;
        };
        DOMWrapper.prototype.isVisible = function () {
            return isElementVisible(this.element);
        };
        DOMWrapper.prototype.text = function () {
            return textContent(this.element);
        };
        DOMWrapper.prototype.html = function () {
            return this.element.outerHTML;
        };
        DOMWrapper.prototype.find = function (selector) {
            var result = this.element.querySelector(selector);
            if (result) {
                return new DOMWrapper(result);
            }
            return createWrapperError('DOMWrapper');
        };
        DOMWrapper.prototype.get = function (selector) {
            var result = this.find(selector);
            if (result instanceof DOMWrapper) {
                return result;
            }
            throw new Error("Unable to get " + selector + " within: " + this.html());
        };
        DOMWrapper.prototype.findAll = function (selector) {
            return Array.from(this.element.querySelectorAll(selector)).map(function (x) { return new DOMWrapper(x); });
        };
        DOMWrapper.prototype.setChecked = function (checked) {
            if (checked === void 0) { checked = true; }
            return __awaiter(this, void 0, void 0, function () {
                var element, type;
                return __generator(this, function (_a) {
                    element = this.element;
                    type = this.attributes().type;
                    if (type === 'radio' && !checked) {
                        throw Error("wrapper.setChecked() cannot be called with parameter false on a '<input type=\"radio\" /> element.");
                    }
                    // we do not want to trigger an event if the user
                    // attempting set the same value twice
                    // this is because in a browser setting checked = true when it is
                    // already true is a no-op; no change event is triggered
                    if (checked === element.checked) {
                        return [2 /*return*/];
                    }
                    element.checked = checked;
                    return [2 /*return*/, this.trigger('change')];
                });
            });
        };
        DOMWrapper.prototype.setValue = function (value) {
            var element = this.element;
            var tagName = element.tagName;
            var type = this.attributes().type;
            if (tagName === 'OPTION') {
                return this.setSelected();
            }
            else if (tagName === 'INPUT' && type === 'checkbox') {
                return this.setChecked(value);
            }
            else if (tagName === 'INPUT' && type === 'radio') {
                return this.setChecked(value);
            }
            else if (tagName === 'INPUT' ||
                tagName === 'TEXTAREA' ||
                tagName === 'SELECT') {
                element.value = value;
                if (tagName === 'SELECT') {
                    return this.trigger('change');
                }
                this.trigger('input');
                // trigger `change` for `v-model.lazy`
                return this.trigger('change');
            }
            else {
                throw Error("wrapper.setValue() cannot be called on " + tagName);
            }
        };
        DOMWrapper.prototype.setSelected = function () {
            var element = this.element;
            if (element.selected) {
                return;
            }
            // todo - review all non-null assertion operators in project
            // search globally for `!.` and with regex `!$`
            element.selected = true;
            var parentElement = element.parentElement;
            if (parentElement.tagName === 'OPTGROUP') {
                parentElement = parentElement.parentElement;
            }
            return new DOMWrapper(parentElement).trigger('change');
        };
        DOMWrapper.prototype.trigger = function (eventString, options) {
            return __awaiter(this, void 0, void 0, function () {
                var isDisabled, event_1;
                var _this = this;
                return __generator(this, function (_a) {
                    if (options && options['target']) {
                        throw Error("[vue-test-utils]: you cannot set the target value of an event. See the notes section " +
                            "of the docs for more details\u2014" +
                            "https://vue-test-utils.vuejs.org/api/wrapper/trigger.html");
                    }
                    isDisabled = function () {
                        var validTagsToBeDisabled = [
                            'BUTTON',
                            'COMMAND',
                            'FIELDSET',
                            'KEYGEN',
                            'OPTGROUP',
                            'OPTION',
                            'SELECT',
                            'TEXTAREA',
                            'INPUT'
                        ];
                        var hasDisabledAttribute = _this.attributes().disabled !== undefined;
                        var elementCanBeDisabled = validTagsToBeDisabled.includes(_this.element.tagName);
                        return hasDisabledAttribute && elementCanBeDisabled;
                    };
                    if (this.element && !isDisabled()) {
                        event_1 = createDOMEvent(eventString, options);
                        this.element.dispatchEvent(event_1);
                    }
                    return [2 /*return*/, vue.nextTick];
                });
            });
        };
        return DOMWrapper;
    }());

    var cacheStringFunction = function (fn) {
        var cache = Object.create(null);
        return (function (str) {
            var hit = cache[str];
            return hit || (cache[str] = fn(str));
        });
    };
    var camelizeRE = /-(\w)/g;
    var camelize = cacheStringFunction(function (str) {
        return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); });
    });
    var capitalize = cacheStringFunction(function (str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    });
    var hyphenateRE = /\B([A-Z])/g;
    var hyphenate = cacheStringFunction(function (str) {
        return str.replace(hyphenateRE, '-$1').toLowerCase();
    });

    function matchName(target, sourceName) {
        var camelized = camelize(target);
        var capitalized = capitalize(camelized);
        return (!!sourceName &&
            (sourceName === target ||
                sourceName === camelized ||
                sourceName === capitalized ||
                capitalize(camelize(sourceName)) === capitalized));
    }

    /**
     * Detect whether a selector matches a VNode
     * @param node
     * @param selector
     * @return {boolean | ((value: any) => boolean)}
     */
    function matches(node, selector) {
        var _a, _b;
        // do not return none Vue components
        if (!node.component)
            return false;
        if (node.type === selector) {
            return true;
        }
        if (typeof selector === 'string') {
            return (_b = (_a = node.el) === null || _a === void 0 ? void 0 : _a.matches) === null || _b === void 0 ? void 0 : _b.call(_a, selector);
        }
        var nodeType = node.type;
        if (typeof selector === 'object' && typeof nodeType === 'object') {
            // we are looking for this exact component
            if (selector === nodeType) {
                return true;
            }
            var componentName = void 0;
            if ('name' in nodeType || 'displayName' in nodeType) {
                // match normal component definitions or functional components
                componentName = nodeType.name || nodeType.displayName;
            }
            var selectorName = selector.name;
            // the component and selector both have a name
            if (componentName && selectorName) {
                return matchName(selectorName, componentName);
            }
            // if a name is missing, then check the locally registered components in the parent
            if (node.component.parent) {
                var registry = node.component.parent.type.components;
                for (var key in registry) {
                    // is it the selector
                    if (!selectorName && registry[key] === selector) {
                        selectorName = key;
                    }
                    // is it the component
                    if (!componentName && registry[key] === nodeType) {
                        componentName = key;
                    }
                }
                // we may have one or both missing names
                if (selectorName && componentName) {
                    return matchName(selectorName, componentName);
                }
            }
        }
        return false;
    }
    /**
     * Filters out the null, undefined and primitive values,
     * to only keep VNode and VNodeArrayChildren values
     * @param value
     */
    function nodesAsObject(value) {
        return !!value && typeof value === 'object';
    }
    /**
     * Collect all children
     * @param nodes
     * @param children
     */
    function aggregateChildren(nodes, children) {
        if (children && Array.isArray(children)) {
            var reversedNodes = __spreadArrays(children).reverse().filter(nodesAsObject);
            reversedNodes.forEach(function (node) {
                if (Array.isArray(node)) {
                    aggregateChildren(nodes, node);
                }
                else {
                    nodes.unshift(node);
                }
            });
        }
    }
    function findAllVNodes(vnode, selector) {
        var matchingNodes = [];
        var nodes = [vnode];
        while (nodes.length) {
            var node = nodes.shift();
            // match direct children
            aggregateChildren(nodes, node.children);
            if (node.component) {
                // match children of the wrapping component
                aggregateChildren(nodes, node.component.subTree.children);
                aggregateChildren(nodes, [node.component.subTree]);
            }
            if (node.suspense) {
                // match children if component is Suspense
                var activeBranch = node.suspense.activeBranch;
                aggregateChildren(nodes, [activeBranch]);
            }
            if (matches(node, selector) && !matchingNodes.includes(node)) {
                matchingNodes.push(node);
            }
        }
        return matchingNodes;
    }
    function find(root, selector) {
        return findAllVNodes(root, selector).map(
        // @ts-ignore
        function (vnode) { return vnode.component.proxy; });
    }

    var events;
    function emitted(vm, eventName) {
        var cid = vm.$.uid;
        var vmEvents = events[cid] || {};
        if (eventName) {
            return vmEvents ? vmEvents[eventName] : undefined;
        }
        return vmEvents;
    }
    var attachEmitListener = function () {
        events = {};
        // use devtools to capture this "emit"
        vue.setDevtoolsHook(createDevTools(events));
    };
    function createDevTools(events) {
        return {
            emit: function (eventType) {
                var payload = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    payload[_i - 1] = arguments[_i];
                }
                if (eventType !== "component:emit" /* COMPONENT_EMIT */)
                    return;
                var componentVM = payload[1], event = payload[2], eventArgs = payload[3];
                recordEvent(events, componentVM, event, eventArgs);
            }
        };
    }
    function recordEvent(events, vm, event, args) {
        // Functional component wrapper creates a parent component
        var wrapperVm = vm;
        while (typeof (wrapperVm === null || wrapperVm === void 0 ? void 0 : wrapperVm.type) === 'function')
            wrapperVm = wrapperVm.parent;
        var cid = wrapperVm.uid;
        if (!(cid in events)) {
            events[cid] = {};
        }
        if (!(event in events[cid])) {
            events[cid][event] = [];
        }
        // Record the event message sent by the emit
        events[cid][event].push(args);
    }

    var VueWrapper = /** @class */ (function () {
        function VueWrapper(app, vm, setProps) {
            this.__app = app;
            // root is null on functional components
            this.rootVM = vm === null || vm === void 0 ? void 0 : vm.$root;
            this.componentVM = vm;
            this.__setProps = setProps;
            config.plugins.VueWrapper.extend(this);
        }
        Object.defineProperty(VueWrapper.prototype, "hasMultipleRoots", {
            get: function () {
                // if the subtree is an array of children, we have multiple root nodes
                return this.vm.$.subTree.shapeFlag === 16 /* ARRAY_CHILDREN */;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VueWrapper.prototype, "parentElement", {
            get: function () {
                return this.vm.$el.parentElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VueWrapper.prototype, "element", {
            get: function () {
                // if the component has multiple root elements, we use the parent's element
                return this.hasMultipleRoots ? this.parentElement : this.vm.$el;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VueWrapper.prototype, "vm", {
            get: function () {
                return this.componentVM;
            },
            enumerable: false,
            configurable: true
        });
        VueWrapper.prototype.props = function (selector) {
            var props = this.componentVM.$props;
            return selector ? props[selector] : props;
        };
        VueWrapper.prototype.classes = function (className) {
            return className
                ? new DOMWrapper(this.element).classes(className)
                : new DOMWrapper(this.element).classes();
        };
        VueWrapper.prototype.attributes = function (key) {
            return key
                ? new DOMWrapper(this.element).attributes(key)
                : new DOMWrapper(this.element).attributes();
        };
        VueWrapper.prototype.exists = function () {
            return true;
        };
        VueWrapper.prototype.emitted = function (eventName) {
            return emitted(this.vm, eventName);
        };
        VueWrapper.prototype.html = function () {
            // cover cases like <Suspense>, multiple root nodes.
            if (this.parentElement['__vue_app__']) {
                return this.parentElement.innerHTML;
            }
            return this.element.outerHTML;
        };
        VueWrapper.prototype.text = function () {
            return textContent(this.element);
        };
        VueWrapper.prototype.find = function (selector) {
            // force using the parentElement to allow finding the root element
            var result = this.parentElement.querySelector(selector);
            if (result) {
                return new DOMWrapper(result);
            }
            return createWrapperError('DOMWrapper');
        };
        VueWrapper.prototype.get = function (selector) {
            var result = this.find(selector);
            if (result instanceof DOMWrapper) {
                return result;
            }
            throw new Error("Unable to get " + selector + " within: " + this.html());
        };
        VueWrapper.prototype.findComponent = function (selector) {
            var _a;
            if (typeof selector === 'object' && 'ref' in selector) {
                var result_1 = this.vm.$refs[selector.ref];
                if (result_1) {
                    return createWrapper(null, result_1);
                }
            }
            var result = find(this.vm.$.subTree, selector);
            if (result.length) {
                return createWrapper(null, result[0]);
            }
            // https://github.com/vuejs/vue-test-utils-next/issues/211
            // VTU v1 supported finding the component mounted itself.
            // eg: mount(Comp).findComponent(Comp)
            // this is the same as doing `wrapper.vm`, but we keep this behavior for back compat.
            if (matches(this.vm.$.vnode, selector)) {
                return createWrapper(null, (_a = this.vm.$.vnode.component) === null || _a === void 0 ? void 0 : _a.proxy);
            }
            return createWrapperError('VueWrapper');
        };
        VueWrapper.prototype.getComponent = function (selector) {
            var result = this.findComponent(selector);
            if (result instanceof VueWrapper) {
                return result;
            }
            var message = 'Unable to get ';
            if (typeof selector === 'string') {
                message += "component with selector " + selector;
            }
            else if (selector.name) {
                message += "component with name " + selector.name;
            }
            else if (selector.ref) {
                message += "component with ref " + selector.ref;
            }
            else {
                message += 'specified component';
            }
            message += " within: " + this.html();
            throw new Error(message);
        };
        VueWrapper.prototype.findAllComponents = function (selector) {
            return find(this.vm.$.subTree, selector).map(function (c) { return createWrapper(null, c); });
        };
        VueWrapper.prototype.findAll = function (selector) {
            var results = this.parentElement.querySelectorAll(selector);
            return Array.from(results).map(function (element) { return new DOMWrapper(element); });
        };
        VueWrapper.prototype.setData = function (data) {
            mergeDeep(this.componentVM.$data, data);
            return vue.nextTick();
        };
        VueWrapper.prototype.setProps = function (props) {
            // if this VM's parent is not the root or if setProps does not exist, error out
            if (this.vm.$parent !== this.rootVM || !this.__setProps) {
                throw Error('You can only use setProps on your mounted component');
            }
            this.__setProps(props);
            return vue.nextTick();
        };
        VueWrapper.prototype.setValue = function (value, prop) {
            var propEvent = prop || 'modelValue';
            this.vm.$emit("update:" + propEvent, value);
            return this.vm.$nextTick();
        };
        VueWrapper.prototype.trigger = function (eventString, options) {
            var rootElementWrapper = new DOMWrapper(this.element);
            return rootElementWrapper.trigger(eventString, options);
        };
        VueWrapper.prototype.unmount = function () {
            // preventing dispose of child component
            if (!this.__app) {
                throw new Error("wrapper.unmount() can only be called by the root wrapper");
            }
            this.__app.unmount(this.parentElement);
        };
        return VueWrapper;
    }());
    function createWrapper(app, vm, setProps) {
        return new VueWrapper(app, vm, setProps);
    }

    var createDataMixin = function (data) {
        return {
            created: function () {
                var _a;
                for (var _i = 0, _b = Object.entries(data); _i < _b.length; _i++) {
                    var _c = _b[_i], k = _c[0], v = _c[1];
                    vue.getCurrentInstance().data = __assign(__assign({}, vue.getCurrentInstance().data), (_a = {}, _a[k] = v, _a));
                }
            }
        };
    };

    var MOUNT_COMPONENT_REF = 'VTU_COMPONENT';
    var MOUNT_PARENT_NAME = 'VTU_ROOT';

    function getSlots(ctx) {
        return !config.renderStubDefaultSlot ? undefined : ctx.$slots;
    }
    var createStub = function (_a) {
        var name = _a.name, props = _a.props, propsDeclaration = _a.propsDeclaration;
        var anonName = 'anonymous-stub';
        var tag = name ? hyphenate(name) + "-stub" : anonName;
        var render = function (ctx) {
            return vue.h(tag, props, getSlots(ctx));
        };
        return vue.defineComponent({
            name: name || anonName,
            render: render,
            props: propsDeclaration
        });
    };
    var createTransitionStub = function (_a) {
        var name = _a.name, props = _a.props;
        var render = function (ctx) {
            return vue.h(name, {}, ctx.$slots);
        };
        return vue.defineComponent({ name: name, render: render, props: props });
    };
    var resolveComponentStubByName = function (componentName, stubs) {
        if (Array.isArray(stubs) && stubs.length) {
            // ['Foo', 'Bar'] => { Foo: true, Bar: true }
            stubs = stubs.reduce(function (acc, current) {
                acc[current] = true;
                return acc;
            }, {});
        }
        for (var _i = 0, _a = Object.entries(stubs); _i < _a.length; _i++) {
            var _b = _a[_i], stubKey = _b[0], value = _b[1];
            if (matchName(componentName, stubKey)) {
                return value;
            }
        }
    };
    var isHTMLElement = function (type) { return typeof type === 'string'; };
    var isCommentOrFragment = function (type) { return typeof type === 'symbol'; };
    var isParent = function (type) {
        return isComponent(type) && type['name'] === MOUNT_PARENT_NAME;
    };
    var isMountedComponent = function (type, props) { return isComponent(type) && props && props['ref'] === MOUNT_COMPONENT_REF; };
    var isComponent = function (type) {
        return typeof type === 'object';
    };
    var isFunctionalComponent$1 = function (type) {
        return typeof type === 'function' && ('name' in type || 'displayName' in type);
    };
    function stubComponents(stubs, shallow) {
        if (stubs === void 0) { stubs = {}; }
        if (shallow === void 0) { shallow = false; }
        vue.transformVNodeArgs(function (args, instance) {
            var nodeType = args[0], props = args[1], children = args[2], patchFlag = args[3], dynamicProps = args[4];
            var type = nodeType;
            // stub transition by default via config.global.stubs
            if (type === vue.Transition && stubs['transition']) {
                return [
                    createTransitionStub({
                        name: 'transition-stub',
                        propsDeclaration: undefined
                    }),
                    undefined,
                    children
                ];
            }
            // stub transition-group by default via config.global.stubs
            if (type === vue.TransitionGroup && stubs['transition-group']) {
                return [
                    createTransitionStub({
                        name: 'transition-group-stub',
                        propsDeclaration: undefined
                    }),
                    undefined,
                    children
                ];
            }
            // args[0] can either be:
            // 1. a HTML tag (div, span...)
            // 2. An object of component options, such as { name: 'foo', render: [Function], props: {...} }
            // Depending what it is, we do different things.
            if (isHTMLElement(type) ||
                isCommentOrFragment(type) ||
                isParent(type) ||
                isMountedComponent(type, props)) {
                return args;
            }
            if (isComponent(type) || isFunctionalComponent$1(type)) {
                var name_1 = type['name'] || type['displayName'];
                // if no name, then check the locally registered components in the parent
                if (!name_1 && instance && instance.parent) {
                    // try to infer the name based on local resolution
                    var registry = instance.type.components;
                    for (var key in registry) {
                        if (registry[key] === type) {
                            name_1 = key;
                            break;
                        }
                    }
                }
                if (!name_1) {
                    return shallow ? ['stub'] : args;
                }
                var stub = resolveComponentStubByName(name_1, stubs);
                // case 2: custom implementation
                if (typeof stub === 'object') {
                    // pass the props and children, for advanced stubbing
                    return [stubs[name_1], props, children, patchFlag, dynamicProps];
                }
                // we return a stub by matching Vue's `h` function
                // where the signature is h(Component, props, slots)
                // case 1: default stub
                if (stub === true || shallow) {
                    var propsDeclaration = (type === null || type === void 0 ? void 0 : type.props) || {};
                    return [
                        createStub({ name: name_1, propsDeclaration: propsDeclaration, props: props }),
                        props,
                        children,
                        patchFlag,
                        dynamicProps
                    ];
                }
            }
            return args;
        });
    }

    // implementation
    function mount(originalComponent, options) {
        // normalise the incoming component
        var component;
        if (isFunctionalComponent(originalComponent)) {
            component = vue.defineComponent({
                setup: function (_, _a) {
                    var attrs = _a.attrs, slots = _a.slots;
                    return function () { return vue.h(originalComponent, attrs, slots); };
                }
            });
        }
        else if (isObjectComponent(originalComponent)) {
            component = __assign({}, originalComponent);
        }
        else {
            component = originalComponent;
        }
        var el = document.createElement('div');
        if (options === null || options === void 0 ? void 0 : options.attachTo) {
            var to = void 0;
            if (typeof options.attachTo === 'string') {
                to = document.querySelector(options.attachTo);
                if (!to) {
                    throw new Error("Unable to find the element matching the selector " + options.attachTo + " given as the `attachTo` option");
                }
            }
            else {
                to = options.attachTo;
            }
            to.appendChild(el);
        }
        // handle any slots passed via mounting options
        var slots = (options === null || options === void 0 ? void 0 : options.slots) &&
            Object.entries(options.slots).reduce(function (acc, _a) {
                var name = _a[0], slot = _a[1];
                // case of an SFC getting passed
                if (typeof slot === 'object' && 'render' in slot && slot.render) {
                    acc[name] = slot.render;
                    return acc;
                }
                if (typeof slot === 'function') {
                    acc[name] = slot;
                    return acc;
                }
                if (typeof slot === 'object') {
                    acc[name] = function () { return slot; };
                    return acc;
                }
                if (typeof slot === 'string') {
                    // if it is HTML we process and render it using h
                    if (isHTML(slot)) {
                        acc[name] = function (props) { return vue.h(processSlot(slot), props); };
                    }
                    // otherwise it is just a string so we just return it as-is
                    else {
                        acc[name] = function () { return slot; };
                    }
                    return acc;
                }
                return acc;
            }, {});
        // override component data with mounting options data
        if (options === null || options === void 0 ? void 0 : options.data) {
            var dataMixin = createDataMixin(options.data());
            component.mixins = __spreadArrays((component.mixins || []), [
                dataMixin
            ]);
        }
        // we define props as reactive so that way when we update them with `setProps`
        // Vue's reactivity system will cause a rerender.
        var props = vue.reactive(__assign(__assign(__assign(__assign({}, options === null || options === void 0 ? void 0 : options.attrs), options === null || options === void 0 ? void 0 : options.propsData), options === null || options === void 0 ? void 0 : options.props), { ref: MOUNT_COMPONENT_REF }));
        var global = mergeGlobalProperties(config.global, options === null || options === void 0 ? void 0 : options.global);
        component.components = __assign(__assign({}, component.components), global.components);
        // create the wrapper component
        var Parent = vue.defineComponent({
            name: MOUNT_PARENT_NAME,
            render: function () {
                return vue.h(component, props, slots);
            }
        });
        var setProps = function (newProps) {
            for (var _i = 0, _a = Object.entries(newProps); _i < _a.length; _i++) {
                var _b = _a[_i], k = _b[0], v = _b[1];
                props[k] = v;
            }
            return vm.$nextTick();
        };
        // add tracking for emitted events
        attachEmitListener();
        // create the app
        var app = vue.createApp(Parent);
        // global mocks mixin
        if (global === null || global === void 0 ? void 0 : global.mocks) {
            var mixin = {
                beforeCreate: function () {
                    for (var _i = 0, _a = Object.entries(global.mocks); _i < _a.length; _i++) {
                        var _b = _a[_i], k = _b[0], v = _b[1];
                        this[k] = v;
                    }
                }
            };
            app.mixin(mixin);
        }
        // AppConfig
        if (global.config) {
            for (var _i = 0, _a = Object.entries(global.config); _i < _a.length; _i++) {
                var _b = _a[_i], k = _b[0], v = _b[1];
                app.config[k] = v;
            }
        }
        // use and plugins from mounting options
        if (global.plugins) {
            for (var _c = 0, _d = global.plugins; _c < _d.length; _c++) {
                var plugin = _d[_c];
                if (Array.isArray(plugin)) {
                    app.use.apply(app, __spreadArrays([plugin[0]], plugin.slice(1)));
                    continue;
                }
                app.use(plugin);
            }
        }
        // use any mixins from mounting options
        if (global.mixins) {
            for (var _e = 0, _f = global.mixins; _e < _f.length; _e++) {
                var mixin = _f[_e];
                app.mixin(mixin);
            }
        }
        if (global.components) {
            for (var _g = 0, _h = Object.keys(global.components); _g < _h.length; _g++) {
                var key = _h[_g];
                app.component(key, global.components[key]);
            }
        }
        if (global.directives) {
            for (var _j = 0, _k = Object.keys(global.directives); _j < _k.length; _j++) {
                var key = _k[_j];
                app.directive(key, global.directives[key]);
            }
        }
        // provide any values passed via provides mounting option
        if (global.provide) {
            for (var _l = 0, _m = Reflect.ownKeys(global.provide); _l < _m.length; _l++) {
                var key = _m[_l];
                // @ts-ignore: https://github.com/microsoft/TypeScript/issues/1863
                app.provide(key, global.provide[key]);
            }
        }
        // stubs
        // even if we are using `mount`, we will still
        // stub out Transition and Transition Group by default.
        stubComponents(global.stubs, options === null || options === void 0 ? void 0 : options.shallow);
        // users expect stubs to work with globally registered
        // compnents, too, such as <router-link> and <router-view>
        // so we register those globally.
        // https://github.com/vuejs/vue-test-utils-next/issues/249
        if (global === null || global === void 0 ? void 0 : global.stubs) {
            for (var _o = 0, _p = Object.entries(global.stubs); _o < _p.length; _o++) {
                var _q = _p[_o], name_1 = _q[0], stub = _q[1];
                var tag = hyphenate(name_1);
                if (stub === true) {
                    // default stub.
                    app.component(tag, createStub({ name: name_1, props: {} }));
                }
                else {
                    // user has provided a custom implementation.
                    app.component(tag, stub);
                }
            }
        }
        // mount the app!
        var vm = app.mount(el);
        // Ingore Avoid app logic that relies on enumerating keys on a component instance... warning
        var warnSave = console.warn;
        console.warn = function () { };
        // get `vm`.
        // for some unknown reason, getting the `vm` for components using `<script setup>`
        // as of Vue 3.0.3 works differently.
        // if `appRef` has keys, use that (vm always has keys like $el, $props etc).
        // if not, use the return value from app.mount.
        var appRef = vm.$refs[MOUNT_COMPONENT_REF];
        var $vm = Reflect.ownKeys(appRef).length ? appRef : vm;
        console.warn = warnSave;
        return createWrapper(app, $vm, setProps);
    }
    var shallowMount = function (component, options) {
        return mount(component, __assign(__assign({}, options), { shallow: true }));
    };

    // TODO: Borrow typings from vue-router-next
    var RouterLinkStub = vue.defineComponent({
        name: 'RouterLinkStub',
        props: {
            to: {
                type: [String, Object],
                required: true
            }
        },
        render: function () {
            var _a, _b;
            return vue.h('a', undefined, (_b = (_a = this.$slots) === null || _a === void 0 ? void 0 : _a.default) === null || _b === void 0 ? void 0 : _b.call(_a));
        }
    });

    var scheduler = typeof setImmediate === 'function' ? setImmediate : setTimeout;
    function flushPromises() {
        return new Promise(function (resolve) {
            scheduler(resolve, 0);
        });
    }

    exports.DOMWrapper = DOMWrapper;
    exports.RouterLinkStub = RouterLinkStub;
    exports.VueWrapper = VueWrapper;
    exports.config = config;
    exports.flushPromises = flushPromises;
    exports.mount = mount;
    exports.shallowMount = shallowMount;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

}({}, Vue, VueCompilerDOM));
