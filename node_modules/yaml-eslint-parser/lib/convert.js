"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertRoot = void 0;
const yaml_1 = __importDefault(require("yaml"));
const utils_1 = require("./utils");
/**
 * Convert yaml-unist-parser root to YAMLProgram
 */
function convertRoot(node, code) {
    const comments = node.comments.map((n) => {
        const c = Object.assign({ type: "Block", value: n.value }, getConvertLocation(n));
        return c;
    });
    let stripCommentCode = "";
    let startIndex = 0;
    for (const comment of comments) {
        stripCommentCode += code.slice(startIndex, comment.range[0]);
        stripCommentCode += code.slice(...comment.range).replace(/\S/gu, " ");
        startIndex = comment.range[1];
    }
    stripCommentCode += code.slice(startIndex);
    const tokens = [];
    const ast = Object.assign({ type: "Program", body: [], comments, sourceType: "module", tokens, parent: null }, getConvertLocation(node));
    for (const n of node.children) {
        ast.body.push(convertDocument(n, tokens, stripCommentCode, ast));
    }
    const useRanges = sort(tokens).map((t) => t.range);
    let range = useRanges.shift();
    let line = 1;
    let column = 0;
    const len = stripCommentCode.length;
    for (let index = 0; index < len; index++) {
        const c = stripCommentCode[index];
        if (c === "\n") {
            line++;
            column = 0;
            continue;
        }
        if (range) {
            while (range && range[1] <= index) {
                range = useRanges.shift();
            }
            if (range && range[0] <= index) {
                column++;
                continue;
            }
        }
        if (isPunctuator(c)) {
            addToken(tokens, "Punctuator", {
                range: [index, index + 1],
                loc: {
                    start: {
                        line,
                        column,
                    },
                    end: {
                        line,
                        column: column + 1,
                    },
                },
            }, stripCommentCode);
        }
        column++;
    }
    sort(tokens);
    return ast;
    /**
     * Checks if the given char is punctuator
     */
    function isPunctuator(c) {
        return (c === ":" ||
            c === "-" ||
            c === "," ||
            c === "{" ||
            c === "}" ||
            c === "[" ||
            c === "]" ||
            c === "?");
    }
}
exports.convertRoot = convertRoot;
/**
 * Convert yaml-unist-parser Document to YAMLDocument
 */
function convertDocument(node, tokens, code, parent) {
    const loc = getConvertLocation(node);
    const ast = Object.assign({ type: "YAMLDocument", directives: [], content: null, parent, anchors: {} }, loc);
    ast.directives.push(...convertDocumentHead(node.children[0], tokens, code, ast));
    ast.content = convertDocumentBody(node.children[1], tokens, code, ast);
    // Marker
    if (code[loc.range[1] - 1] === ".") {
        const range = [loc.range[1] - 3, loc.range[1]];
        addToken(tokens, "Marker", {
            range,
            loc: {
                start: {
                    line: loc.loc.end.line,
                    column: loc.loc.end.column - 3,
                },
                end: clone(loc.loc.end),
            },
        }, code);
    }
    return ast;
}
/**
 * Convert yaml-unist-parser DocumentHead to YAMLDirective[]
 */
function* convertDocumentHead(node, tokens, code, parent) {
    for (const n of node.children) {
        yield convertDirective(n, tokens, code, parent);
    }
    const loc = getConvertLocation(node);
    // Marker
    if (code[loc.range[1] - 1] === "-") {
        const range = [loc.range[1] - 3, loc.range[1]];
        addToken(tokens, "Marker", {
            range,
            loc: {
                start: {
                    line: loc.loc.end.line,
                    column: loc.loc.end.column - 3,
                },
                end: clone(loc.loc.end),
            },
        }, code);
    }
}
/**
 * Convert yaml-unist-parser Directive to YAMLDirective
 */
function convertDirective(node, tokens, code, parent) {
    const loc = getConvertLocation(node);
    const value = code.slice(...loc.range);
    const ast = Object.assign({ type: "YAMLDirective", value,
        parent }, loc);
    addToken(tokens, "Directive", clone(loc), code);
    return ast;
}
/**
 * Convert yaml-unist-parser DocumentBody to YAMLContent
 */
function convertDocumentBody(node, tokens, code, parent) {
    const contentNode = node.children[0];
    return contentNode
        ? convertContentNode(contentNode, tokens, code, parent, parent)
        : null;
}
/**
 * Convert yaml-unist-parser ContentNode to YAMLContent
 */
function convertContentNode(node, tokens, code, parent, doc) {
    if (node.type === "mapping") {
        return convertMapping(node, tokens, code, parent, doc);
    }
    if (node.type === "flowMapping") {
        return convertFlowMapping(node, tokens, code, parent, doc);
    }
    if (node.type === "sequence") {
        return convertSequence(node, tokens, code, parent, doc);
    }
    if (node.type === "flowSequence") {
        return convertFlowSequence(node, tokens, code, parent, doc);
    }
    if (node.type === "plain") {
        return convertPlain(node, tokens, code, parent, doc);
    }
    if (node.type === "quoteDouble") {
        return convertQuoteDouble(node, tokens, code, parent, doc);
    }
    if (node.type === "quoteSingle") {
        return convertQuoteSingle(node, tokens, code, parent, doc);
    }
    if (node.type === "blockLiteral") {
        return convertBlockLiteral(node, tokens, code, parent, doc);
    }
    if (node.type === "blockFolded") {
        return convertBlockFolded(node, tokens, code, parent, doc);
    }
    if (node.type === "alias") {
        return convertAlias(node, tokens, code, parent, doc);
    }
    throw new Error(`Unsupported node: ${node.type}`);
}
/**
 * Convert yaml-unist-parser Mapping to YAMLBlockMapping
 */
function convertMapping(node, tokens, code, parent, doc) {
    const loc = getConvertLocation(node);
    const ast = Object.assign({ type: "YAMLMapping", style: "block", pairs: [], parent }, loc);
    for (const n of node.children) {
        ast.pairs.push(convertMappingItem(n, tokens, code, ast, doc));
    }
    const last = ast.pairs[ast.pairs.length - 1];
    if (last && ast.range[1] !== last.range[1]) {
        // adjust location
        ast.range[1] = last.range[1];
        ast.loc.end = clone(last.loc.end);
    }
    return convertAnchorAndTag(node, tokens, code, parent, ast, doc, ast);
}
/**
 * Convert yaml-unist-parser FlowMapping to YAMLFlowMapping
 */
function convertFlowMapping(node, tokens, code, parent, doc) {
    const loc = getConvertLocation(node);
    const ast = Object.assign({ type: "YAMLMapping", style: "flow", pairs: [], parent }, loc);
    for (const n of node.children) {
        ast.pairs.push(convertMappingItem(n, tokens, code, ast, doc));
    }
    return convertAnchorAndTag(node, tokens, code, parent, ast, doc, ast);
}
/**
 * Convert yaml-unist-parser MappingItem to YAMLPair
 */
function convertMappingItem(node, tokens, code, parent, doc) {
    const loc = getConvertLocation(node);
    const ast = Object.assign({ type: "YAMLPair", key: null, value: null, parent }, loc);
    ast.key = convertMappingKey(node.children[0], tokens, code, ast, doc);
    ast.value = convertMappingValue(node.children[1], tokens, code, ast, doc);
    if (ast.value && ast.range[1] !== ast.value.range[1]) {
        // adjust location
        ast.range[1] = ast.value.range[1];
        ast.loc.end = clone(ast.value.loc.end);
    }
    return ast;
}
/**
 * Convert yaml-unist-parser MappingKey to YAMLContent
 */
function convertMappingKey(node, tokens, code, parent, doc) {
    if (node.children.length) {
        return convertContentNode(node.children[0], tokens, code, parent, doc);
    }
    return null;
}
/**
 * Convert yaml-unist-parser MappingValue to YAMLContent
 */
function convertMappingValue(node, tokens, code, parent, doc) {
    if (node.children.length) {
        return convertContentNode(node.children[0], tokens, code, parent, doc);
    }
    return null;
}
/**
 * Convert yaml-unist-parser Sequence to YAMLBlockSequence
 */
function convertSequence(node, tokens, code, parent, doc) {
    const loc = getConvertLocation(node);
    const ast = Object.assign({ type: "YAMLSequence", style: "block", entries: [], parent }, loc);
    for (const n of node.children) {
        ast.entries.push(...convertSequenceItem(n, tokens, code, ast, doc));
    }
    const last = ast.entries[ast.entries.length - 1];
    if (last && ast.range[1] !== last.range[1]) {
        // adjust location
        ast.range[1] = last.range[1];
        ast.loc.end = clone(last.loc.end);
    }
    return convertAnchorAndTag(node, tokens, code, parent, ast, doc, ast);
}
/**
 * Convert yaml-unist-parser FlowSequence to YAMLFlowSequence
 */
function convertFlowSequence(node, tokens, code, parent, doc) {
    const loc = getConvertLocation(node);
    const ast = Object.assign({ type: "YAMLSequence", style: "flow", entries: [], parent }, loc);
    for (const n of node.children) {
        if (n.type === "flowSequenceItem") {
            ast.entries.push(...convertFlowSequenceItem(n, tokens, code, ast, doc));
        }
        if (n.type === "flowMappingItem") {
            const map = Object.assign({ type: "YAMLMapping", style: "block", pairs: [], parent }, getConvertLocation(n));
            const pair = convertMappingItem(n, tokens, code, map, doc);
            map.pairs.push(pair);
            ast.entries.push(map);
        }
    }
    return convertAnchorAndTag(node, tokens, code, parent, ast, doc, ast);
}
/**
 * Convert yaml-unist-parser SequenceItem to YAMLContent
 */
function* convertSequenceItem(node, tokens, code, parent, doc) {
    if (node.children.length) {
        yield convertContentNode(node.children[0], tokens, code, parent, doc);
    }
    else {
        yield null;
    }
}
/**
 * Convert yaml-unist-parser FlowSequenceItem to YAMLContent
 */
function* convertFlowSequenceItem(node, tokens, code, parent, doc) {
    if (node.children.length) {
        yield convertContentNode(node.children[0], tokens, code, parent, doc);
    }
}
/**
 * Convert yaml-unist-parser Plain to YAMLPlainScalar
 */
function convertPlain(node, tokens, code, parent, doc) {
    const loc = getConvertLocation(node);
    if (loc.range[0] < loc.range[1]) {
        const strValue = node.value;
        let value;
        if (utils_1.isTrue(strValue)) {
            value = true;
        }
        else if (utils_1.isFalse(strValue)) {
            value = false;
        }
        else if (utils_1.isNull(strValue)) {
            value = null;
        }
        else if (needParse(strValue)) {
            value = yaml_1.default.parse(strValue) || strValue;
        }
        else {
            value = strValue;
        }
        const ast = Object.assign({ type: "YAMLScalar", style: "plain", strValue,
            value, raw: code.slice(...loc.range), parent }, loc);
        const type = typeof value;
        if (type === "boolean") {
            addToken(tokens, "Boolean", clone(loc), code);
        }
        else if (type === "number" && isFinite(Number(value))) {
            addToken(tokens, "Numeric", clone(loc), code);
        }
        else if (value === null) {
            addToken(tokens, "Null", clone(loc), code);
        }
        else {
            addToken(tokens, "Identifier", clone(loc), code);
        }
        return convertAnchorAndTag(node, tokens, code, parent, ast, doc, loc);
    }
    return convertAnchorAndTag(node, tokens, code, parent, null, doc, loc);
    /**
     * Checks if the given string needs to be parsed
     */
    function needParse(str) {
        return (
        // oct
        /^0o([0-7]+)$/u.test(str) ||
            // int
            /^[-+]?[0-9]+$/u.test(str) ||
            // hex
            /^0x([0-9a-fA-F]+)$/u.test(str) ||
            // nan
            /^(?:[-+]?\.inf|(\.nan))$/iu.test(str) ||
            // exp
            /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/u.test(str) ||
            // float
            /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/u.test(str)
        // date
        // || /^\d{4}-\d{2}-\d{2}/u.test(str)
        );
    }
}
/**
 * Convert yaml-unist-parser QuoteDouble to YAMLDoubleQuotedScalar
 */
function convertQuoteDouble(node, tokens, code, parent, doc) {
    const loc = getConvertLocation(node);
    const strValue = node.value;
    const ast = Object.assign({ type: "YAMLScalar", style: "double-quoted", strValue, value: strValue, raw: code.slice(...loc.range), parent }, loc);
    addToken(tokens, "String", clone(loc), code);
    return convertAnchorAndTag(node, tokens, code, parent, ast, doc, ast);
}
/**
 * Convert yaml-unist-parser QuoteSingle to YAMLSingleQuotedScalar
 */
function convertQuoteSingle(node, tokens, code, parent, doc) {
    const loc = getConvertLocation(node);
    const strValue = node.value;
    const ast = Object.assign({ type: "YAMLScalar", style: "single-quoted", strValue, value: strValue, raw: code.slice(...loc.range), parent }, loc);
    addToken(tokens, "String", clone(loc), code);
    return convertAnchorAndTag(node, tokens, code, parent, ast, doc, ast);
}
/**
 * Convert yaml-unist-parser BlockLiteral to YAMLBlockLiteral
 */
function convertBlockLiteral(node, tokens, code, parent, doc) {
    const loc = getConvertLocation(node);
    const value = node.value;
    const ast = Object.assign({ type: "YAMLScalar", style: "literal", chomping: node.chomping, indent: node.indent, value,
        parent }, loc);
    const text = code.slice(...loc.range);
    if (text.startsWith("|")) {
        let line = loc.loc.start.line;
        let column = loc.loc.start.column + 1;
        const offset = loc.range[0];
        let index = 1;
        while (index < text.length) {
            const c = text[index];
            if (!c.trim()) {
                break;
            }
            column++;
            index++;
        }
        const punctuatorLoc = {
            range: [offset, offset + index],
            loc: {
                start: clone(loc.loc.start),
                end: {
                    line,
                    column,
                },
            },
        };
        addToken(tokens, "Punctuator", punctuatorLoc, code);
        let lineFeed = false;
        while (index < text.length) {
            const c = text[index];
            if (c.trim()) {
                break;
            }
            if (c === "\n") {
                if (lineFeed) {
                    break;
                }
                line++;
                column = 0;
                lineFeed = true;
            }
            else {
                column++;
            }
            index++;
        }
        const tokenLoc = {
            range: [offset + index, loc.range[1]],
            loc: {
                start: {
                    line,
                    column,
                },
                end: clone(loc.loc.end),
            },
        };
        if (tokenLoc.range[0] < tokenLoc.range[1]) {
            addToken(tokens, "BlockLiteral", tokenLoc, code);
        }
    }
    else {
        // ??
        addToken(tokens, "BlockLiteral", clone(loc), code);
    }
    return convertAnchorAndTag(node, tokens, code, parent, ast, doc, ast);
}
/**
 * Convert yaml-unist-parser BlockFolded to YAMLBlockFolded
 */
function convertBlockFolded(node, tokens, code, parent, doc) {
    const loc = getConvertLocation(node);
    const value = node.value;
    const ast = Object.assign({ type: "YAMLScalar", style: "folded", chomping: node.chomping, indent: node.indent, value,
        parent }, loc);
    const text = code.slice(...loc.range);
    if (text.startsWith(">")) {
        let line = loc.loc.start.line;
        let column = loc.loc.start.column + 1;
        const offset = loc.range[0];
        let index = 1;
        while (index < text.length) {
            const c = text[index];
            if (!c.trim()) {
                break;
            }
            column++;
            index++;
        }
        const punctuatorLoc = {
            range: [offset, offset + index],
            loc: {
                start: clone(loc.loc.start),
                end: {
                    line,
                    column,
                },
            },
        };
        addToken(tokens, "Punctuator", punctuatorLoc, code);
        let lineFeed = false;
        while (index < text.length) {
            const c = text[index];
            if (c.trim()) {
                break;
            }
            if (c === "\n") {
                if (lineFeed) {
                    break;
                }
                line++;
                column = 0;
                lineFeed = true;
            }
            else {
                column++;
            }
            index++;
        }
        const tokenLoc = {
            range: [offset + index, loc.range[1]],
            loc: {
                start: {
                    line,
                    column,
                },
                end: clone(loc.loc.end),
            },
        };
        if (tokenLoc.range[0] < tokenLoc.range[1]) {
            addToken(tokens, "BlockFolded", tokenLoc, code);
        }
    }
    else {
        // ??
        addToken(tokens, "BlockFolded", clone(loc), code);
    }
    return convertAnchorAndTag(node, tokens, code, parent, ast, doc, ast);
}
/**
 * Convert yaml-unist-parser Alias to YAMLAlias
 */
function convertAlias(node, tokens, code, parent, doc) {
    const loc = getConvertLocation(node);
    const value = node.value;
    const ast = Object.assign({ type: "YAMLAlias", name: value, parent }, loc);
    const text = code.slice(...loc.range);
    if (text.startsWith("*")) {
        const punctuatorLoc = {
            range: [loc.range[0], loc.range[0] + 1],
            loc: {
                start: clone(loc.loc.start),
                end: {
                    line: loc.loc.start.line,
                    column: loc.loc.start.column + 1,
                },
            },
        };
        addToken(tokens, "Punctuator", punctuatorLoc, code);
        const tokenLoc = {
            range: [punctuatorLoc.range[1], loc.range[1]],
            loc: {
                start: clone(punctuatorLoc.loc.end),
                end: clone(loc.loc.end),
            },
        };
        if (tokenLoc.range[0] < tokenLoc.range[1]) {
            addToken(tokens, "Identifier", tokenLoc, code);
        }
    }
    else {
        // ??
        addToken(tokens, "Identifier", clone(loc), code);
    }
    return convertAnchorAndTag(node, tokens, code, parent, ast, doc, ast);
}
/**
 * Convert yaml-unist-parser Anchor and Tag
 */
function convertAnchorAndTag(node, tokens, code, parent, value, doc, valueLoc) {
    if (node.anchor || node.tag) {
        const ast = {
            type: "YAMLWithMeta",
            anchor: null,
            tag: null,
            value,
            parent,
            range: clone(valueLoc.range),
            loc: clone(valueLoc.loc),
        };
        if (value) {
            value.parent = ast;
        }
        if (node.anchor) {
            const anchor = convertAnchor(node.anchor, tokens, code, ast, doc);
            ast.anchor = anchor;
            ast.range[0] = anchor.range[0];
            ast.loc.start = clone(anchor.loc.start);
        }
        if (node.tag) {
            const tag = convertTag(node.tag, tokens, code, ast);
            ast.tag = tag;
            if (tag.range[0] < ast.range[0]) {
                ast.range[0] = tag.range[0];
                ast.loc.start = clone(tag.loc.start);
            }
        }
        return ast;
    }
    return value;
}
/**
 * Convert yaml-unist-parser Anchor to YAMLAnchor
 */
function convertAnchor(node, tokens, code, parent, doc) {
    const loc = getConvertLocation(node);
    const value = node.value;
    const ast = Object.assign({ type: "YAMLAnchor", name: value, parent }, loc);
    const anchors = doc.anchors[value] || (doc.anchors[value] = []);
    anchors.push(ast);
    const text = code.slice(...loc.range);
    if (text.startsWith("&")) {
        const punctuatorLoc = {
            range: [loc.range[0], loc.range[0] + 1],
            loc: {
                start: clone(loc.loc.start),
                end: {
                    line: loc.loc.start.line,
                    column: loc.loc.start.column + 1,
                },
            },
        };
        addToken(tokens, "Punctuator", punctuatorLoc, code);
        const tokenLoc = {
            range: [punctuatorLoc.range[1], loc.range[1]],
            loc: {
                start: clone(punctuatorLoc.loc.end),
                end: clone(loc.loc.end),
            },
        };
        if (tokenLoc.range[0] < tokenLoc.range[1]) {
            addToken(tokens, "Identifier", tokenLoc, code);
        }
    }
    else {
        // ??
        addToken(tokens, "Identifier", clone(loc), code);
    }
    return ast;
}
/**
 * Convert yaml-unist-parser Anchor to YAMLTag
 */
function convertTag(node, tokens, code, parent) {
    const loc = getConvertLocation(node);
    const value = node.value;
    const ast = Object.assign({ type: "YAMLTag", tag: value, parent }, loc);
    const text = code.slice(...loc.range);
    if (text.startsWith("!")) {
        const offset = text.startsWith("!!") ? 2 : 1;
        const punctuatorLoc = {
            range: [loc.range[0], loc.range[0] + offset],
            loc: {
                start: clone(loc.loc.start),
                end: {
                    line: loc.loc.start.line,
                    column: loc.loc.start.column + offset,
                },
            },
        };
        addToken(tokens, "Punctuator", punctuatorLoc, code);
        const tokenLoc = {
            range: [punctuatorLoc.range[1], loc.range[1]],
            loc: {
                start: clone(punctuatorLoc.loc.end),
                end: clone(loc.loc.end),
            },
        };
        if (tokenLoc.range[0] < tokenLoc.range[1]) {
            addToken(tokens, "Identifier", tokenLoc, code);
        }
    }
    else {
        // ??
        addToken(tokens, "Identifier", clone(loc), code);
    }
    return ast;
}
/**
 * Get the location information of the given node.
 * @param node The node.
 */
function getConvertLocation(node) {
    const { start, end } = node.position;
    return {
        range: [start.offset, end.offset],
        loc: {
            start: {
                line: start.line,
                column: start.column - 1,
            },
            end: {
                line: end.line,
                column: end.column - 1,
            },
        },
    };
}
/**
 * clone the location.
 */
function clone(loc) {
    if (typeof loc !== "object") {
        return loc;
    }
    if (Array.isArray(loc)) {
        return loc.map(clone);
    }
    const n = {};
    for (const key in loc) {
        n[key] = clone(loc[key]);
    }
    return n;
}
/**
 * Add token to tokens
 */
function addToken(tokens, type, loc, code) {
    tokens.push(Object.assign({ type, value: code.slice(...loc.range) }, loc));
}
/**
 * Sort tokens
 */
function sort(tokens) {
    return tokens.sort((a, b) => {
        if (a.range[0] > b.range[0]) {
            return 1;
        }
        if (a.range[0] < b.range[0]) {
            return -1;
        }
        if (a.range[1] > b.range[1]) {
            return 1;
        }
        if (a.range[1] < b.range[1]) {
            return -1;
        }
        return 0;
    });
}
