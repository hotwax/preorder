"use strict";
exports.__esModule = true;
var lines_and_columns_1 = require("lines-and-columns");
var attach_1 = require("./attach");
var root_1 = require("./factories/root");
var preprocess_1 = require("./preprocess");
var transform_1 = require("./transform");
var content_1 = require("./transforms/content");
var error_1 = require("./transforms/error");
var offset_1 = require("./transforms/offset");
var range_1 = require("./transforms/range");
var add_orig_range_1 = require("./utils/add-orig-range");
var remove_fake_nodes_1 = require("./utils/remove-fake-nodes");
var update_positions_1 = require("./utils/update-positions");
var YAML = require("./yaml");
function parse(text) {
    var cst = YAML.parseCST(text);
    add_orig_range_1.addOrigRange(cst);
    var documents = cst.map(function (cstDocument) {
        return new YAML.Document({
            merge: false,
            keepCstNodes: true
        }).parse(cstDocument);
    });
    var locator = new lines_and_columns_1["default"](text);
    var comments = [];
    var context = {
        text: text,
        locator: locator,
        comments: comments,
        transformOffset: function (offset) { return offset_1.transformOffset(offset, context); },
        transformRange: function (range) { return range_1.transformRange(range, context); },
        transformNode: function (node) { return transform_1.transformNode(node, context); },
        transformContent: function (node) { return content_1.transformContent(node, context); }
    };
    for (var _i = 0, documents_1 = documents; _i < documents_1.length; _i++) {
        var document = documents_1[_i];
        for (var _a = 0, _b = document.errors; _a < _b.length; _a++) {
            var error = _b[_a];
            if (error instanceof YAML.YAMLSemanticError &&
                error.message === 'Map keys must be unique; "<<" is repeated') {
                continue;
            }
            throw error_1.transformError(error, context);
        }
    }
    documents.forEach(function (document) { return preprocess_1.removeCstBlankLine(document.cstNode); });
    var root = root_1.createRoot(context.transformRange({ origStart: 0, origEnd: context.text.length }), documents.map(context.transformNode), comments);
    attach_1.attachComments(root);
    update_positions_1.updatePositions(root);
    remove_fake_nodes_1.removeFakeNodes(root);
    return root;
}
exports.parse = parse;
