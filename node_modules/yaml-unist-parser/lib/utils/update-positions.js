"use strict";
exports.__esModule = true;
var create_updater_1 = require("./create-updater");
var get_last_1 = require("./get-last");
function updatePositions(node) {
    if (node === null || !("children" in node)) {
        return;
    }
    var children = node.children;
    children.forEach(updatePositions);
    if (node.type === "document") {
        var _a = node.children, head = _a[0], body = _a[1];
        if (head.position.start.offset === head.position.end.offset) {
            head.position.start = head.position.end = body.position.start;
        }
        else if (body.position.start.offset === body.position.end.offset) {
            body.position.start = body.position.end = head.position.end;
        }
    }
    var updateStartPoint = create_updater_1.createUpdater(node.position, startPointGetter, startPointSetter, shouldUpdateStartPoint);
    var updateEndPoint = create_updater_1.createUpdater(node.position, endPointGetter, endPointSetter, shouldUpdateEndPoint);
    if ("endComments" in node && node.endComments.length !== 0) {
        updateStartPoint(node.endComments[0].position.start);
        updateEndPoint(get_last_1.getLast(node.endComments).position.end);
    }
    var nonNullChildren = children.filter(function (child) { return child !== null; });
    if (nonNullChildren.length !== 0) {
        var firstChild = nonNullChildren[0];
        var lastChild = get_last_1.getLast(nonNullChildren);
        updateStartPoint(firstChild.position.start);
        updateEndPoint(lastChild.position.end);
        if ("leadingComments" in firstChild &&
            firstChild.leadingComments.length !== 0) {
            updateStartPoint(firstChild.leadingComments[0].position.start);
        }
        if ("tag" in firstChild && firstChild.tag) {
            updateStartPoint(firstChild.tag.position.start);
        }
        if ("anchor" in firstChild && firstChild.anchor) {
            updateStartPoint(firstChild.anchor.position.start);
        }
        if ("trailingComment" in lastChild && lastChild.trailingComment) {
            updateEndPoint(lastChild.trailingComment.position.end);
        }
    }
}
exports.updatePositions = updatePositions;
function startPointGetter(position) {
    return position.start;
}
function startPointSetter(position, point) {
    position.start = point;
}
function endPointGetter(position) {
    return position.end;
}
function endPointSetter(position, point) {
    position.end = point;
}
function shouldUpdateStartPoint(reduced, value) {
    return value.offset < reduced.offset;
}
function shouldUpdateEndPoint(reduced, value) {
    return value.offset > reduced.offset;
}
